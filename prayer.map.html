<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JCS Prayer Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<style>
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    background: #f7f8ff url('background-translucent.png') center/cover no-repeat fixed;
    /* Soft glow overlay */
    background-blend-mode: lighten;
  }
  #map {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 0;
  }
  .prayer-popup {
    font-family: "Georgia", serif;
    font-size: 1rem;
    color: #4b2e83;
    text-shadow: 0 1px 1px rgba(255,255,255,0.8);
  }
</style>
</head>
<body>

<div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/xrpl/build/xrpl-latest-min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {

  // 1. Create Leaflet map with OpenStreetMap tiles
  const map = L.map('map', {
    attributionControl: true,
    zoomControl: true
  }).setView([20, 0], 2);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors',
    detectRetina: true,
    maxZoom: 18
  }).addTo(map);

  const prayerMarkers = L.layerGroup().addTo(map);

  // 2. Decode functions for XRPL memos
  function decodeHexMemo(memoHex) {
    memoHex = memoHex.replace(/^0x/, '');
    const bytes = new Uint8Array(memoHex.length / 2);
    for (let i = 0; i < bytes.length; i++) {
      bytes[i] = parseInt(memoHex.substr(i*2, 2), 16);
    }
    return new TextDecoder().decode(bytes);
  }

  function addPrayerMarker(lat, lon, message, address) {
    let content = `<div class="prayer-popup"><strong>Prayer:</strong> ${message || '(No text)'}`;
    if (address) content += `<br/><em>${address}</em>`;
    content += '</div>';
    L.marker([lat, lon]).addTo(prayerMarkers).bindPopup(content);
  }

  // 3. Main fetch from XRPL
  async function displayPrayersFromXRPL() {
    const PRAYER_ACCOUNT = 'rPT1Sjq2YGrBMTttX4GZHjKu9dyfzbpAYe';
    prayerMarkers.clearLayers();
    const client = new xrpl.Client('wss://s.altnet.rippletest.net:51233');
    await client.connect();

    let txs;
    try {
      const resp = await client.request({
        command: 'account_tx',
        account: PRAYER_ACCOUNT,
        ledger_index_min: -1,
        ledger_index_max: -1,
        limit: 200
      });
      txs = resp.result.transactions;
    } catch (err) {
      console.error('XRPL fetch error:', err);
      await client.disconnect();
      return;
    }

    for (const tx of txs) {
      try {
        const memos = (tx.tx && tx.tx.Memos) || (tx.tx_json && tx.tx_json.Memos);
        if (Array.isArray(memos)) {
          for (const memoObj of memos) {
            const memoHex = memoObj.Memo.MemoData;
            if (!memoHex) continue;
            try {
              const jsonStr = decodeHexMemo(memoHex);
              const prayer = JSON.parse(jsonStr);
              if (typeof prayer.lat === 'number' && typeof prayer.lon === 'number') {
                addPrayerMarker(prayer.lat, prayer.lon, prayer.message, prayer.address);
              }
            } catch {}
          }
        }
      } catch {}
    }

    if (prayerMarkers.getLayers().length > 0) {
      map.fitBounds(prayerMarkers.getBounds(), { maxZoom: 8, padding: [40, 40] });
    }

    await client.disconnect();
  }

  displayPrayersFromXRPL();
  setInterval(displayPrayersFromXRPL, 60000);

  // Auto-resize fix
  window.addEventListener('resize', () => { map.invalidateSize(); });

});
</script>
</body>
</html>

