<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Basic Meta -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jesus Christ Saves Token (JCS) | XRPL Portal, Trading & Liquidity Sentinel</title>

  <!-- AI / Security manifests -->
  <link rel="ai-manifest" href="/universal-ai.json">
  <link rel="security" href="/.well-known/security.txt">
  <link rel="schema.dcterms" href="/ai/schemas/universal-ai.v1.json">
  <link rel="alternate" type="application/json" href="/.well-known/ai.json">
  <link rel="source" href="/ai/provenance.json">

  <!-- Favicons & App Icons -->
  <link rel="icon" href="https://jesuschristsavestoken.com/jcs-logo.png" type="image/png" />
  <link rel="icon" type="image/png" sizes="16x16" href="https://jesuschristsavestoken.com/jcs-logo-16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="https://jesuschristsavestoken.com/jcs-logo-32.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="https://jesuschristsavestoken.com/jcs-logo-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="https://jesuschristsavestoken.com/jcs-logo-512.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="https://jesuschristsavestoken.com/jcs-logo-180.png" />
  <link rel="mask-icon" href="https://jesuschristsavestoken.com/safari-pinned-tab.svg" color="#004e92" />
  <meta name="msapplication-TileImage" content="https://jesuschristsavestoken.com/jcs-logo-270.png" />
  <meta name="msapplication-TileColor" content="#004e92" />
  <meta name="theme-color" content="#004e92" />

  <!-- SEO -->
  <meta name="description" content="Jesus Christ Saves Token (JCS) is a faith-centered digital asset on the XRP Ledger with a non-custodial trading portal, Liquidity Sentinel, and live XRPL metrics." />
  <meta name="keywords" content="Jesus Christ Saves Token, JCS, XRPL, XRP Ledger, Christian Cryptocurrency, Faith Blockchain, Christian Token, Crypto Ministry, Prayer, Jesus" />
  <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
  <link rel="canonical" href="https://jesuschristsavestoken.com/" />
  <link rel="alternate" hreflang="en" href="https://jesuschristsavestoken.com/" />

  <!-- Open Graph -->
  <meta property="og:locale" content="en_US" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Jesus Christ Saves Token" />
  <meta property="og:title" content="Jesus Christ Saves Token (JCS) | XRPL Portal & Liquidity Sentinel" />
  <meta property="og:description" content="Faith-based JCS token on the XRP Ledger with a non-custodial trading portal, Liquidity Sentinel, and live XRPL analytics." />
  <meta property="og:url" content="https://jesuschristsavestoken.com/" />
  <meta property="og:image" content="https://jesuschristsavestoken.com/jcs-logo.png" />
  <meta property="og:image:alt" content="Jesus Christ Saves Token Logo" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="@JesusCS_token" />
  <meta name="twitter:title" content="Jesus Christ Saves Token (JCS) | XRPL Portal & Liquidity Sentinel" />
  <meta name="twitter:description" content="Faith-driven, community-focused JCS on XRPL. Verify. Pray. Build transparently." />
  <meta name="twitter:image" content="https://jesuschristsavestoken.com/jcs-logo.png" />

  <!-- JSON-LD Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "name": "Jesus Christ Saves Token",
    "url": "https://jesuschristsavestoken.com/",
    "logo": "https://jesuschristsavestoken.com/jcs-logo.png",
    "sameAs": [
      "https://x.com/JesusCS_token"
    ]
  }
  </script>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "url": "https://jesuschristsavestoken.com/",
    "name": "Jesus Christ Saves Token (JCS)",
    "description": "Faith-based cryptocurrency on the XRPL pointing to Jesus Christ through transparent, immutable infrastructure.",
    "publisher": {
      "@type": "Organization",
      "name": "Jesus Christ Saves Token",
      "logo": {
        "@type": "ImageObject",
        "url": "https://jesuschristsavestoken.com/jcs-logo.png"
      }
    }
  }
  </script>

  <!-- Preconnects -->
  <link rel="preconnect" href="https://xumm.app" crossorigin>
  <link rel="preconnect" href="https://xaman.app" crossorigin>
  <link rel="preconnect" href="https://xrbitcoincash-github-io.onrender.com" crossorigin>
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700&family=UnifrakturCook:wght@700&display=swap" rel="stylesheet" />

  <!-- CSP (extended for XRPL, Coingecko, fonts, JS CDNs) -->
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' https://xumm.app https://xaman.app https://cdn.jsdelivr.net https://unpkg.com;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
    img-src 'self' data: https:;
    font-src 'self' https://fonts.gstatic.com data:;
    connect-src 'self' https://xumm.app https://oauth2.xumm.app https://xaman.app https://xrbitcoincash-github-io.onrender.com wss://xrplcluster.com https://api.coingecko.com;
    frame-src 'self' https://xumm.app https://oauth2.xumm.app https://xaman.app;
    base-uri 'self';
    form-action 'self';
  ">

  <!-- Base layout + UI styles (Portal + Landing) -->
  <style>
    :root{
      --wrap:1100px;
      --bg:#020817;
      --panel:#050b18;
      --panel-2:#050814;
      --ink:#e5e7eb;
      --muted:#9ca3af;
      --line:#1f2933;
      --ok:#22c55e;
      --err:#ef4444;
      --blue:#2563eb;
      --yellow:#f59e0b;
      --shadow:rgba(0,0,0,.35);
      --accent:#38bdf8;
      --font:system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","SF Pro Display","Segoe UI","Montserrat",sans-serif;
    }

    *{box-sizing:border-box}

    html,
    body{
      margin:0;
      padding:0;
      background:radial-gradient(circle at top,#0b1020 0%,#020308 40%,#000000 100%);
      color:var(--ink);
      font:14px/1.5 var(--font);
      max-width:100%;
      overflow-x:hidden;
    }

    a{
      color:var(--accent);
      text-decoration:none;
    }
    a:hover{text-decoration:underline}

    /* Background */
    .bg-nodes{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:-1;
      background:
        radial-gradient(900px 500px at 10% 0,rgba(56,189,248,.12),transparent),
        radial-gradient(900px 600px at 100% 0,rgba(16,185,129,.06),transparent);
    }

    /* Layout */
    .container{
      max-width:var(--wrap);
      margin:0 auto;
      padding:0 16px;
    }

    /* Header (landing-style) */
    header{
      position:sticky;
      top:0;
      z-index:50;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 6vw;
      backdrop-filter:blur(14px);
      background:rgba(0,0,0,0.78);
      border-bottom:1px solid rgba(255,255,255,0.08);
    }
    header img{
      height:44px;
      border-radius:10px;
      border:1px solid var(--line);
      background:#020617;
    }
    nav{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
    }
    nav a{
      text-decoration:none;
      font-weight:500;
      color:#f5f5f5;
      padding-bottom:4px;
      border-bottom:2px solid transparent;
      font-size:12px;
      transition:color .25s,border-color .25s;
    }
    nav a:hover{
      color:#ffd700;
      border-color:#ffd700;
    }
    .nav-pill-btn{
      border-radius:999px;
      padding:6px 10px;
      border:1px solid var(--line);
      font-size:11px;
      background:radial-gradient(circle at 0 0,rgba(56,189,248,.08),transparent),
                 linear-gradient(180deg,var(--panel),var(--panel-2));
      box-shadow:0 6px 18px var(--shadow);
    }

    /* Hero (landing) */
    .hero{
      min-height:70vh;
      padding:48px 6vw 24px;
      display:grid;
      grid-template-columns:minmax(0,3fr) minmax(260px,2fr);
      gap:32px;
      align-items:center;
      position:relative;
    }
    .hero h1{
      font-family:"UnifrakturCook",cursive;
      font-size:2.6rem;
      margin:0 0 12px;
      color:#ffd700;
      letter-spacing:1px;
    }
    .hero p{
      margin:0 0 14px;
      font-size:0.98rem;
      line-height:1.7;
      color:#e0e0e0;
    }
    .hero .subline{
      margin-bottom:14px;
      font-size:0.9rem;
      color:#cfd8dc;
    }
    .cta{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-bottom:16px;
    }
    .cta a{
      padding:9px 16px;
      border-radius:999px;
      text-decoration:none;
      font-size:0.9rem;
      font-weight:600;
      display:inline-flex;
      align-items:center;
      gap:6px;
      border:1px solid rgba(255,255,255,0.16);
      color:#fff;
      background:radial-gradient(circle at top left,rgba(255,215,0,0.14),transparent);
      transition:all .22s ease;
    }
    .cta a:hover{
      transform:translateY(-2px);
      box-shadow:0 0 16px rgba(255,215,0,0.3);
      border-color:#ffd700;
    }

    #verseCard,#jesusWordsCard{
      margin-top:8px;
      padding:10px 12px;
      border-radius:12px;
      background:radial-gradient(circle at top,rgba(255,215,0,0.15),rgba(0,0,0,0.98));
      border:1px solid rgba(255,255,255,0.1);
      font-size:0.9rem;
    }
    #verseCard strong,
    #jesusWordsCard strong{
      font-size:0.8rem;
      text-transform:uppercase;
      letter-spacing:1px;
      color:#ffd700;
    }
    .muted{
      color:#b0bec5;
      font-size:0.86rem;
    }

    .hero-side-panel{
      padding:14px 14px 12px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,0.09);
      background:radial-gradient(circle at top,rgba(255,255,255,0.04),rgba(0,0,0,0.98));
      display:flex;
      flex-direction:column;
      gap:8px;
      font-size:0.85rem;
    }
    .hero-side-panel h2{
      margin:0;
      font-size:1.05rem;
      color:#ffd700;
    }
    .hero-side-panel ul{
      list-style:none;
      padding:0;
      margin:6px 0 0;
      display:grid;
      gap:4px;
    }
    .hero-side-panel li span.label{color:#90a4ae;}
    .pill{
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:3px 9px;
      border-radius:999px;
      border:1px solid rgba(144,164,174,0.55);
      font-size:0.7rem;
      color:#cfd8dc;
      background:#020814;
    }

    /* Portal cards / layout (from portal) */
    .grid{
      display:grid;
      grid-template-columns:repeat(12,1fr);
      gap:10px;
    }
    .card{
      background:linear-gradient(180deg,var(--panel),var(--panel-2));
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      box-shadow:0 10px 30px var(--shadow);
      margin-top:10px;
    }
    .card--third{grid-column:span 4;}
    .card--half{grid-column:span 6;}

    .card__head{
      display:flex;
      gap:6px;
      align-items:center;
      font-weight:700;
      margin-bottom:4px;
    }
    .card__title{
      font-size:14px;
    }
    .card__text{
      color:var(--muted);
      font-size:12px;
      margin:0;
    }

    .issuer-code{
      display:block;
      border:1px solid var(--line);
      padding:7px;
      border-radius:10px;
      background:#020814;
      color:#c7d2fe;
      word-break:break-all;
      font-size:11px;
    }

    .section-title{
      margin:0 0 6px;
      font-size:16px;
      font-weight:700;
    }
    .status{
      font-size:11px;
      color:var(--muted);
      margin:3px 0 0;
    }
    .status.ok{color:var(--ok);}
    .status.err{color:var(--err);}
    .hint{
      font-size:11px;
      color:var(--muted);
      margin:4px 0 0;
    }
    .mono{
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
    }
    .small{font-size:11px;}
    .nowrap{white-space:nowrap;}

    .badge{
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      font-size:10px;
      color:var(--muted);
    }
    .badge.mainnet{
      background:#050816;
      color:#c7d2fe;
      border-color:#374151;
    }

    table{
      width:100%;
      border-collapse:collapse;
      font-size:10.5px;
      margin-top:6px;
    }
    th,
    td{
      padding:5px 6px;
      border-bottom:1px solid #111827;
      text-align:left;
      vertical-align:top;
    }
    th{
      font-size:10px;
      color:var(--muted);
      font-weight:600;
    }

    .log{
      max-height:180px;
      overflow:auto;
      border-radius:10px;
      background:#020814;
      border:1px solid var(--line);
      padding:7px;
      font-size:10px;
      white-space:pre-wrap;
    }

    .progress{
      height:5px;
      background:#050814;
      border-radius:999px;
      overflow:hidden;
      margin-top:6px;
    }
    .progress > span{
      display:block;
      height:100%;
      width:0;
      background:var(--blue);
      transition:width .18s ease-out;
    }

    .eco-link{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 8px;
      border-radius:10px;
      border:1px solid var(--line);
      background:linear-gradient(180deg,var(--panel),var(--panel-2));
      color:var(--ink);
      text-decoration:none;
      font-size:11px;
    }
    .eco-link img{
      width:20px;
      height:20px;
      border-radius:5px;
      border:1px solid var(--line);
      object-fit:cover;
    }

    footer{
      border-top:1px solid var(--line);
      padding:16px 0 18px;
      margin-top:24px;
      background:radial-gradient(600px 200px at 10% 0,rgba(56,189,248,.04),transparent);
    }

    /* Trading block (portal) */
    #trade.card{margin-top:14px;}
    #trade .trade-logo{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:13px;
      font-weight:700;
      margin-bottom:6px;
    }
    #trade .asset-chip{
      display:inline-flex;
      align-items:center;
      gap:5px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      font-size:10px;
      background:#020814;
    }
    #trade .asset-chip img{
      width:14px;
      height:14px;
      border-radius:3px;
    }

    .tabset{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:4px;
      margin:4px 0 6px;
    }
    .tab{
      border-radius:999px;
      border:1px solid var(--line);
      background:#020814;
      color:var(--muted);
      padding:5px 8px;
      font-size:11px;
      cursor:pointer;
      text-align:center;
    }
    .tab.active{
      background:var(--blue);
      color:#e5e7eb;
      border-color:var(--blue);
    }

    .field{margin-top:6px;}
    .field label{
      display:block;
      font-size:10px;
      color:var(--muted);
      margin-bottom:2px;
    }
    .field input{
      width:100%;
      padding:6px 8px;
      border-radius:10px;
      border:1px solid #111827;
      background:#020814;
      color:var(--ink);
      font-size:11px;
    }

    .amount-row{
      display:flex;
      align-items:center;
      gap:6px;
    }
    .amount-row img{
      width:16px;
      height:16px;
      border-radius:4px;
    }

    .quick-amounts{
      display:grid;
      grid-template-columns:repeat(4,1fr);
      gap:4px;
      margin-top:4px;
    }
    .quick-amounts .qa{
      padding:4px 0;
      border-radius:8px;
      border:1px solid var(--line);
      background:#020814;
      color:var(--muted);
      font-size:10px;
      cursor:pointer;
    }

    .best-price-strip{
      display:flex;
      align-items:center;
      gap:6px;
      margin-top:6px;
    }
    .best-price-btn{
      font-size:10px;
      padding:4px 8px;
      border-radius:999px;
    }

    .total-line{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-top:4px;
      font-size:10px;
      color:var(--muted);
    }

    .button-row{
      display:grid;
      grid-template-columns:auto auto;
      gap:6px;
      align-items:center;
      margin-top:6px;
    }
    .button-row .btn{
      font-size:10px;
      padding:6px 10px;
    }

    .btn{
      border:1px solid var(--line);
      border-radius:999px;
      background:
        radial-gradient(circle at 0 0,rgba(56,189,248,.06),transparent),
        linear-gradient(180deg,var(--panel),var(--panel-2));
      color:var(--ink);
      padding:7px 11px;
      font-size:12px;
      font-weight:600;
      cursor:pointer;
      min-height:32px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      text-decoration:none;
      box-shadow:0 6px 18px var(--shadow);
      white-space:nowrap;
    }
    .btn--primary{
      border-color:var(--accent);
      box-shadow:0 10px 26px rgba(56,189,248,.18);
    }
    .btn:disabled{
      opacity:.5;
      cursor:not-allowed;
      box-shadow:none;
    }

    #xrbSecurityCode{
      display:none;
      margin-top:6px;
      text-align:center;
      font-size:13px;
      font-weight:800;
      letter-spacing:0.18em;
      color:#facc15;
      padding:4px 14px;
      border-radius:12px;
      background:rgba(0,0,0,.9);
      box-shadow:0 0 8px rgba(0,0,0,.95),0 0 18px rgba(0,0,0,.9);
    }

    /* Sentinel health table */
    #healthWrap{
      overflow:auto;
      margin-top:6px;
    }
    #healthTable{
      min-width:720px;
    }
    #healthTable img{
      width:14px;
      height:14px;
      border-radius:3px;
      background:#020817;
      border:1px solid rgba(56,189,248,.18);
      object-fit:cover;
    }
    .icon-star{
      cursor:pointer;
      font-size:12px;
      margin-right:3px;
      user-select:none;
      color:#4b5563;
    }
    .icon-star.on{
      color:#fde047;
      filter:drop-shadow(0 0 6px rgba(250,204,21,.35));
    }
    .pill.H{
      border-color:#22c55e;
      color:#22c55e;
    }
    .pill.C{
      border-color:#f59e0b;
      color:#fbbf24;
    }
    .pill.R{
      border-color:#ef4444;
      color:#f87171;
    }

    /* Portal metrics layout */
    #portalMetrics{
      margin-top:10px;
    }
    #portalMetrics #xrbtcSummary{
      margin-top:4px;
    }
    #portalMetrics > div:nth-of-type(2){
      display:grid !important;
      grid-template-columns:1.4fr 1fr;
      gap:10px;
      margin-top:8px;
    }
    #portalMetrics > div:nth-of-type(2) h3.small{
      margin:0 0 4px;
    }

    /* Landing sections */
    section.landing-section{
      padding:24px 6vw 8px;
    }
    section.landing-section h2{
      font-size:1.6rem;
      margin-bottom:10px;
      color:#ffd700;
    }
    .section-lede{
      font-size:0.95rem;
      color:#cfd8dc;
      max-width:760px;
      margin-bottom:12px;
    }

    .highlight-grid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(210px,1fr));
      gap:14px;
      margin-bottom:8px;
    }
    .info-card{
      padding:12px 12px 9px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,0.08);
      background:radial-gradient(circle at top left,rgba(255,255,255,0.02),rgba(0,0,0,0.98));
      font-size:0.86rem;
      color:#cfd8dc;
    }
    .info-card h3{
      margin:0 0 6px;
      font-size:1rem;
      color:#ffe082;
    }

    .checklist{
      list-style:none;
      padding:0;
      margin:0;
      display:grid;
      gap:4px;
      font-size:0.86rem;
    }

    .metrics-grid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(140px,1fr));
      gap:12px;
      margin-top:4px;
    }
    .metric{
      padding:10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.09);
      background:rgba(0,0,0,0.9);
    }
    .metric .label{
      font-size:0.78rem;
      text-transform:uppercase;
      color:#90a4ae;
      margin-bottom:3px;
    }
    .metric .value{
      font-size:1rem;
      font-weight:600;
      color:#ffffff;
    }

    .prayer-wall{
      display:grid;
      grid-template-columns:minmax(0,2.2fr) minmax(220px,1.5fr);
      gap:16px;
    }
    .prayer-list{
      display:grid;
      gap:8px;
      font-size:0.86rem;
      color:#cfd8dc;
    }
    .prayer-item strong{
      color:#ffe082;
      font-size:0.82rem;
    }
    .notice{
      font-size:0.75rem;
      color:#90a4ae;
      margin-top:4px;
    }

    .faq-cards{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(230px,1fr));
      gap:12px;
    }

    /* Responsive */
    @media (max-width:900px){
      .hero{
        grid-template-columns:1fr;
        padding-top:70px;
      }
    }
    @media (max-width:720px){
      header{
        padding:8px 12px;
        flex-direction:column;
        align-items:flex-start;
        gap:6px;
      }
      nav{
        justify-content:flex-start;
      }
      .hero h1{
        font-size:2.1rem;
      }
      .grid{
        grid-template-columns:repeat(12,1fr);
      }
      .card--third,
      .card--half{
        grid-column:span 12;
      }
      #portalMetrics > div:nth-of-type(2){
        display:block !important;
        margin-top:6px;
      }
      #portalMetrics > div:nth-of-type(2) > div{
        margin-top:6px;
      }
      .log{
        max-height:140px;
        font-size:9px;
      }
      .btn,
      .nav-pill-btn{
        font-size:11px;
        padding:6px 10px;
        min-height:30px;
      }
    }
  </style>
</head>
<body id="top">
<noscript style="position:fixed;top:0;left:0;right:0;background:#000;color:#fff;padding:10px;text-align:center;z-index:9999;">
  This site works best with JavaScript enabled.
</noscript>

<div class="bg-nodes" aria-hidden="true"></div>
<div id="particles-js"></div>

<!-- Header -->
<header>
  <img src="https://jesuschristsavestoken.com/jcs-logo.png" alt="Jesus Christ Saves Token Logo" />
  <nav aria-label="Primary navigation">
    <a href="#home">Home</a>
    <a href="#about">About</a>
    <a href="#mission">Mission</a>
    <a href="#trade">Trade</a>
    <a href="#portalMetrics">DEX Metrics</a>
    <a href="#sentinel">Sentinel</a>
    <a href="#metrics">Token Metrics</a>
    <a href="#prayer">Prayer</a>
    <a href="#faq">FAQ</a>
  </nav>
</header>

<main>
  <!-- HERO -->
  <section class="hero" id="home">
    <div>
      <h1>Jesus Christ Saves Token (JCS)</h1>
      <p>
        JCS is a faith-based token on the XRP Ledger that uses transparent,
        immutable infrastructure to point every transaction, every holder,
        and every prayer back to one Name: Jesus Christ.
      </p>
      <p class="subline">
        Verified issuer: <strong>rPU6sXCNzsjcTUEmgJQ5SxDUzY2y1RyYKd</strong> ‚Ä¢
        Ticker: <strong>JCS</strong> ‚Ä¢ XRPL mainnet ‚Ä¢ Domain TOML-verified.
      </p>
      <div class="cta">
        <a href="https://xrpl.services/?issuer=rPU6sXCNzsjcTUEmgJQ5SxDUzY2y1RyYKd&currency=JCS&limit=1000000000000" target="_blank" rel="noopener">
          ‚ûï Set Trustline
        </a>
        <a href="https://xpmarket.com/token/JCS-rPU6sXCNzsjcTUEmgJQ5SxDUzY2y1RyYKd" target="_blank" rel="noopener">
          üîó View on XPMarket
        </a>
        <a href="https://sologenic.org/trade?market=JCS%2BrPU6sXCNzsjcTUEmgJQ5SxDUzY2y1RyYKd%2FXRP" target="_blank" rel="noopener">
          üïä Trade JCS on Sologenic
        </a>
        <a href="#trade">
          üìà Open JCS Portal
        </a>
      </div>

      <div id="verseCard">
        <strong>Scripture of the Day</strong>
        <p id="dailyVerse" class="muted">Loading‚Ä¶</p>
      </div>

      <div id="jesusWordsCard">
        <strong>Words of Jesus (Daily Rotation)</strong>
        <p id="jesusWords" class="muted">Loading‚Ä¶</p>
      </div>
    </div>

    <aside class="hero-side-panel">
      <h2>On-Ledger Integrity</h2>
      <span class="pill">‚úî TOML Verified Domain</span>
      <span class="pill">‚úî Xaman KYC Flag</span>
      <span class="pill">‚úî Immutable public issuer</span>
      <ul>
        <li><span class="label">Network:</span> XRP Ledger Mainnet</li>
        <li><span class="label">Symbol:</span> JCS</li>
        <li><span class="label">Issuer:</span> rPU6sXCNzsjcTUEmgJQ5SxDUzY2y1RyYKd</li>
        <li><span class="label">Use:</span> Prayer-driven community, charity support, Christian builders</li>
      </ul>
      <p class="muted">
        Always verify both <strong>JCS</strong> and the correct issuer before adding trustlines or trading.
      </p>
    </aside>
  </section>

  <!-- INFO GRID (portal cards) -->
  <section class="section">
    <div class="container grid">
      <article class="card card--third">
        <div class="card__head">
          <span>‚úùÔ∏è</span><div class="card__title">About JCS</div>
        </div>
        <p class="card__text">
          Jesus Christ Saves (JCS) is a spiritually inspired token on the XRP Ledger, promoting faith, hope,
          and purpose through a digital community. Non-custodial and user-controlled.
        </p>
      </article>
      <article class="card card--third">
        <div class="card__head">
          <span>‚öôÔ∏è</span><div class="card__title">Xaman-native</div>
        </div>
        <p class="card__text">
          All actions prepare XRPL payloads that you review and sign in Xaman. No keys, no custody.
        </p>
      </article>
      <article class="card card--third">
        <div class="card__head">
          <span>üõ°Ô∏è</span><div class="card__title">Liquidity Sentinel</div>
        </div>
        <p class="card__text">
          Integrated wallet health scan, AMM pool checks, and JSON export for audits and record-keeping.
        </p>
      </article>
      <article class="card card--half">
        <div class="card__head">
          <span>üîó</span><div class="card__title">Jesus Christ Saves (JCS) asset</div>
        </div>
        <p class="card__text"><strong>Issuer</strong></p>
        <code class="issuer-code">rPU6sXCNzsjcTUEmgJQ5SxDUzY2y1RyYKd</code>
        <p class="card__text" style="margin-top:8px"><strong>Currency (HEX)</strong></p>
        <code class="issuer-code">4A43530000000000000000000000000000000000</code>
        <p class="card__text" style="margin-top:8px">
          JCS ¬∑ Decimals: 6 ¬∑ XRPL mainnet ¬∑ Domain TOML-verified at jesuschristsavestoken.com.
        </p>
      </article>
    </div>
  </section>

  <!-- ABOUT (narrative) -->
  <section id="about" class="landing-section" aria-label="About JCS">
    <h2>‚úù About Jesus Christ Saves Token</h2>
    <p class="section-lede">
      JCS is not a replacement for faith, church, or Scripture. It is a focused digital witness:
      a tokenized reminder that Jesus Christ saves, anchored on a public ledger where records cannot be quietly altered.
    </p>
    <div class="highlight-grid">
      <div class="info-card">
        <h3>Immutable Witness</h3>
        <p>
          The XRP Ledger records every JCS movement in public view. This transparency reflects our conviction
          that stewardship, giving, and leadership should be accountable and in the light.
        </p>
      </div>
      <div class="info-card">
        <h3>Prayer-Minded Utility</h3>
        <p>
          JCS holders are invited to unite in regular on-ledger prayer campaigns, support verifiable ministries,
          and highlight needs that the Body of Christ can meet.
        </p>
      </div>
      <div class="info-card">
        <h3>Community of Believers</h3>
        <p>
          JCS is designed for Christians, ministries, and builders who want technology that openly confesses Christ
          and resists anonymity-driven abuse.
        </p>
      </div>
      <div class="info-card">
        <h3>Sound Warnings</h3>
        <p>
          JCS is not financial advice, not a promise of profit, and not a substitute for personal conviction.
          Always verify issuer data and beware imitators.
        </p>
      </div>
    </div>
  </section>

  <!-- MISSION -->
  <section id="mission" class="landing-section" aria-label="Mission and Vision">
    <h2>üïä Mission: Let Every Block Point Back to Christ</h2>
    <p class="section-lede">
      ‚ÄúFor where your treasure is, there will your heart be also.‚Äù (Matthew 6:21)
      JCS aims to align digital activity with eternal perspective.
    </p>
    <div class="container">
      <div class="info-card">
        <h3>Three Pillars</h3>
        <ul class="checklist">
          <li>‚úÖ <strong>Confession:</strong> Every brand element boldly names Jesus Christ.</li>
          <li>‚úÖ <strong>Clarity:</strong> Public issuer, verified domain, verifiable token metadata.</li>
          <li>‚úÖ <strong>Charity:</strong> Framework for transparent ministry support and community-led giving.</li>
          <li>‚ú® <strong>Prayer Integration:</strong> Rotating verses and prompts keep the focus on Christ, not charts.</li>
          <li>‚ú® <strong>Creative Witness:</strong> Future content and NFT drops centered on the Gospel message.</li>
        </ul>
      </div>
    </div>
  </section>

  <!-- WALLET STATUS (portal) -->
  <section class="container">
    <article class="card">
      <div style="display:flex;justify-content:space-between;gap:8px;flex-wrap:wrap;align-items:center">
        <div>
          <div class="section-title">Wallet connection</div>
          <p id="walletStatus" class="status">Status: Not connected</p>
        </div>
        <div style="display:flex;flex-direction:column;align-items:flex-end;gap:4px">
          <span id="netBadge" class="badge mainnet">XRPL Mainnet</span>
          <div style="display:flex;gap:4px;flex-wrap:wrap;justify-content:flex-end">
            <button id="connectWalletBtn" class="btn small" type="button">Connect Xaman</button>
            <button id="disconnectWalletBtn" class="btn small" type="button" disabled>Disconnect</button>
            <a href="https://xaman.app" class="btn small" target="_blank" rel="noopener">Download Xaman</a>
          </div>
          <button id="setTrustlineBtn" class="btn small" type="button" disabled>
            Add JCS Trust Line
          </button>
        </div>
      </div>
      <p id="trustlineMsg" class="hint"></p>
      <div id="xrbSecurityCode" aria-live="polite"></div>
    </article>
  </section>

  <!-- TRADE (portal) -->
  <section class="container">
    <article id="trade" class="card" aria-label="JCS Trading">
      <div class="trade-logo">
        <span class="asset-chip">
          <img src="./jcs-logo.png" alt="Jesus Christ Saves (JCS)" width="24" height="24">
          JCS
        </span>
        <span>/</span>
        <span class="asset-chip">XRP</span>
      </div>
      <div class="tabset" role="tablist">
        <button id="buyTab" class="tab active" type="button" role="tab" aria-selected="true">Buy JCS</button>
        <button id="sellTab" class="tab" type="button" role="tab" aria-selected="false">Sell JCS</button>
      </div>
      <div id="sideExplain" class="small">
        <div class="note buy">Buying: trade XRP to receive JCS.</div>
        <div class="note sell" hidden>Selling: trade JCS to receive XRP.</div>
      </div>
      <div class="field">
        <label for="amount" id="amountLabel">Amount (JCS)</label>
        <div class="amount-row">
          <img
            src="./jcs-logo.png"
            alt="Jesus Christ Saves (JCS)"
            width="16"
            height="16"
            loading="lazy"
          >
          <input
            id="amount"
            type="number"
            step="0.000001"
            inputmode="decimal"
            placeholder="0.000000"
          >
        </div>
        <div class="quick-amounts" aria-label="Quick amount">
          <button class="qa" data-q="25" type="button">25%</button>
          <button class="qa" data-q="50" type="button">50%</button>
          <button class="qa" data-q="75" type="button">75%</button>
          <button class="qa" data-q="100" type="button">100%</button>
        </div>
        <div id="amountHint" class="hint">
          Amount to <span id="actionWord">buy</span>. You trade XRP to receive JCS.
        </div>
      </div>
      <div class="best-price-strip">
        <button id="suggestPriceBtn" class="btn best-price-btn" type="button">Best price from AMM / book</button>
        <div class="hint">Uses XRPL AMM and top-of-book. Auto-refresh while amount is set.</div>
      </div>
      <div class="field">
        <label for="price">Limit price (XRP per JCS)</label>
        <input id="price" type="number" step="0.000001" inputmode="decimal" placeholder="e.g. 0.500000">
        <div class="hint">For market swap, leave pricing to the AMM helper below.</div>
      </div>
      <div class="total-line">
        <span>Total</span>
        <strong id="totalXrp">0.000000 XRP</strong>
      </div>
      <div class="button-row">
        <button id="placeOfferBtn" class="btn btn--primary" type="button" disabled>Place limit order</button>
        <button id="marketTradeBtn" class="btn" type="button" disabled>Market swap (AMM, 2% cap)</button>
      </div>
      <p id="tradeMsg" class="status">‚Äî</p>
      <select id="side" hidden>
        <option value="buy" selected>Buy</option>
        <option value="sell">Sell</option>
      </select>
      <input id="orderType" type="hidden" value="limit">
    </article>
  </section>

  <!-- OPEN ORDERS (portal) -->
  <section class="container">
    <article id="open-orders" class="card" aria-label="Open orders">
      <h2 class="section-title">Open orders ¬∑ Extract & cancel</h2>
      <p class="hint">
        View your JCS-related offers and cancel individually or in bulk. Signing always in Xaman with a sentinel memo code.
      </p>
      <div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:6px">
        <button id="btnRefreshOffers" class="btn" type="button">Refresh orders</button>
        <button id="btnCancelAll" class="btn" type="button">Cancel all visible</button>
      </div>
      <div class="progress"><span id="offersProgress"></span></div>
      <div id="offersWrap" class="hint" style="margin-top:6px">No data yet.</div>
      <p id="offersStatus" class="status"></p>
    </article>
  </section>

  <!-- PORTAL METRICS (order book + ledger) -->
  <section class="container">
    <article id="portalMetrics" class="card" aria-label="JCS / XRP portal metrics">
      <h2 class="section-title">JCS / XRP ¬∑ Live DEX metrics</h2>
      <div id="xrbtcSummary" class="hint">
        <span id="xrbtcSpot">Spot: ‚Äî</span> ¬∑
        <span id="xrbtcAmm">AMM: ‚Äî</span> ¬∑
        <span id="xrbtcSpread">Spread: ‚Äî</span> ¬∑
        <span id="xrbtcLedgerMini">Ledger: ‚Äî</span>
      </div>
      <div style="display:grid;grid-template-columns:1.4fr 1fr;gap:10px;margin-top:8px">
        <div>
          <h3 class="small">Order book (top levels)</h3>
          <div id="priceOutput" class="hint">‚Äî</div>
        </div>
        <div>
          <h3 class="small">Ledger snapshot</h3>
          <pre id="ledgerOutput" class="log">‚Äî</pre>
        </div>
      </div>
    </article>
  </section>

  <!-- LIQUIDITY SENTINEL + QUICK BUY + LOG + LEGAL (portal) -->
  <section class="container" id="sentinel">
    <article class="card">
      <h2 class="section-title">Liquidity Sentinel ¬∑ Wallet liquidity health</h2>
      <p class="hint">
        Scans your trustlines, finds XRPL AMM pools (XRP/IOU), estimates slippage, scores tokens, and tracks changes.
      </p>
      <div style="display:flex;flex-wrap:wrap;gap:6px;align-items:center;margin-top:4px">
        <button id="btnHealthScan" class="btn" type="button" disabled>Scan health</button>
        <label class="hint"><input id="riskOnly" type="checkbox"> Risk only</label>
        <label class="hint"><input id="watchOnly" type="checkbox"> Watchlist only</label>
        <label class="hint"><input id="autoRefresh" type="checkbox"> Auto-refresh</label>
        <select id="autoEvery" class="hint">
          <option value="15" selected>15s</option>
          <option value="30">30s</option>
          <option value="60">60s</option>
        </select>
        <span id="lastScan" class="status">Last scan: ‚Äî</span>
        <span id="ledgerPill" class="badge">Ledger: ‚Äî</span>
      </div>
      <div class="progress"><span id="healthProgress"></span></div>
      <p id="healthStatus" class="status"></p>
      <div id="healthWrap">
        <table id="healthTable" style="display:none">
          <thead>
          <tr>
            <th>‚≠ê</th>
            <th>Token / Hex<br><span class="small">Issuer</span></th>
            <th>Pool</th>
            <th>Reserves<br><span class="small">XRP / IOU</span></th>
            <th>Fee</th>
            <th>Slippage<br><span class="small">10 / 100 XRP</span></th>
            <th>Score</th>
            <th>Status</th>
          </tr>
          </thead>
          <tbody id="healthBody"></tbody>
        </table>
      </div>
      <p id="healthNote" class="hint">Connect wallet to enable scanning.</p>
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:6px">
        <button id="btnExportJson" class="btn" type="button">Export JSON</button>
        <button id="btnCopyJson" class="btn" type="button">Copy JSON</button>
        <button id="btnHealthRetry" class="btn" type="button">Retry</button>
      </div>
    </article>

    <article class="card">
      <h2 class="section-title">Quick buy ¬∑ JCS</h2>
      <p class="hint">Pathfinding via XRPL with 2% slippage cap. Requires JCS trustline. Signing in Xaman.</p>
      <div style="display:flex;flex-direction:column;gap:4px;margin-top:4px">
        <div style="display:flex;align-items:center;gap:6px">
          <button id="buy1" class="btn btn--primary" type="button">Buy 1 JCS</button>
          <span id="est1" class="status">‚âà ‚Äî XRP</span>
        </div>
        <div style="display:flex;align-items:center;gap:6px">
          <button id="buy25" class="btn" type="button">Buy 25 JCS</button>
          <span id="est25" class="status">‚âà ‚Äî XRP</span>
        </div>
        <div style="display:flex;align-items:center;gap:6px">
          <button id="buy50" class="btn" type="button">Buy 50 JCS</button>
          <span id="est50" class="status">‚âà ‚Äî XRP</span>
        </div>
        <div style="display:flex;align-items:center;gap:6px">
          <button id="buy100" class="btn" type="button">Buy 100 JCS</button>
          <span id="est100" class="status">‚âà ‚Äî XRP</span>
        </div>
        <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
          <button id="btnRefreshEst" class="btn" type="button">Refresh estimates</button>
          <button id="btnTrustXRBT" class="btn" type="button">Add JCS trust line</button>
        </div>
        <p class="hint">
          Issuer:
          <span class="mono">rPU6sXCNzsjcTUEmgJQ5SxDUzY2y1RyYKd</span>
        </p>
        <p id="buyStatus" class="status"></p>
      </div>
    </article>

    <article class="card">
      <h2 class="section-title">Results & activity log</h2>
      <div id="resultBox" class="hint">Receipts and messages will appear here.</div>
      <div style="margin-top:6px;display:flex;gap:6px;align-items:center">
        <button id="btnClearLog" class="btn" type="button">Clear log</button>
      </div>
      <pre id="log" class="log" aria-live="polite"></pre>
    </article>

    <article class="card">
      <h2 class="section-title">Important</h2>
      <div class="small" style="border-left:3px solid var(--yellow);padding-left:8px">
        <p><strong>Non-custodial.</strong> This page constructs XRPL transactions that you must review and sign in your own Xaman wallet.</p>
        <p><strong>No brokerage or guarantees.</strong> No custody, no discretionary routing, no advice. Market conditions and routes can change between preview and signing.</p>
        <p><strong>Irreversible.</strong> XRPL transactions are final once validated. Verify asset, issuer, amounts, and memos before signing.</p>
      </div>
    </article>
  </section>

  <!-- TOKEN METRICS (USD etc) -->
  <section id="metrics" class="landing-section" aria-label="JCS Token Metrics">
    <h2>üìä Live Token Metrics</h2>
    <p class="section-lede">
      Indicative on-ledger data for JCS. Values update using public XRPL order books and XRP/USD feeds.
    </p>
    <div class="container">
      <div class="metrics-grid" role="list">
        <div class="metric" role="listitem" aria-live="polite">
          <div class="label muted">Price (USD)</div>
          <div id="price" class="value">‚Äî</div>
        </div>
        <div class="metric" role="listitem" aria-live="polite">
          <div class="label muted">Estimated Market Cap</div>
          <div id="marketcap" class="value">‚Äî</div>
        </div>
        <div class="metric" role="listitem" aria-live="polite">
          <div class="label muted">Circulating Supply</div>
          <div id="supply" class="value">‚Äî</div>
        </div>
        <div class="metric" role="listitem" aria-live="polite">
          <div class="label muted">24h Change</div>
          <div id="change" class="value">N/A</div>
        </div>
      </div>
      <p class="muted" style="margin-top:10px;">
        Data is informational. Always confirm on-ledger before large decisions.
      </p>
    </div>
  </section>

  <!-- PRAYER & PARTICIPATION -->
  <section id="prayer" class="landing-section" aria-label="Prayer and Participation">
    <h2>üôè Prayer, Stewardship, and Participation</h2>
    <p class="section-lede">
      JCS exists to keep Christ central. Hold if you wish, share if you are led,
      but above all, pray. The goal is a visible, verifiable trail of faith-driven action.
    </p>
    <div class="container">
      <div class="prayer-wall">
        <div class="info-card">
          <h3>Prayer Wall (Concept)</h3>
          <div class="prayer-list">
            <div class="prayer-item">
              <strong>For Ministries:</strong>
              Lord, guide resources toward honest, Christ-centered work with transparent use.
            </div>
            <div class="prayer-item">
              <strong>For Holders:</strong>
              May every wallet remember the poor, the lost, and the persecuted Church.
            </div>
            <div class="prayer-item">
              <strong>For Builders:</strong>
              Let Christian developers honor You with code that reflects truth and integrity.
            </div>
            <div class="prayer-item">
              <strong>For Witness:</strong>
              May this project always exalt Jesus‚Äô name above any token or metric.
            </div>
          </div>
          <p class="notice">
            Future updates can integrate signed on-ledger ‚Äúprayer signals‚Äù without exposing private data.
          </p>
        </div>
        <div class="info-card">
          <h3>How To Engage</h3>
          <ul class="checklist">
            <li>Set the JCS trustline with the verified issuer.</li>
            <li>Use only official links listed on this site.</li>
            <li>Join community calls, prayer threads, and Gospel-centered initiatives.</li>
            <li>Never share your secret keys; no JCS feature ever requires them.</li>
          </ul>
        </div>
      </div>
    </div>
  </section>

  <!-- FAQ -->
  <section id="faq" class="landing-section" aria-label="Frequently Asked Questions">
    <h2>‚ùì FAQ</h2>
    <div class="container">
      <div class="faq-cards">
        <article class="info-card">
          <h3>Why a Christian token?</h3>
          <p>
            To plant a clear testimony of Jesus Christ inside Web3, using transparent rails
            where faith, generosity, and accountability can be verified.
          </p>
        </article>

        <article class="info-card">
          <h3>Is this a church or ministry?</h3>
          <p>
            No. JCS is a technology and branding layer that openly confesses Christ.
            Individual believers and ministries choose how to use it.
          </p>
        </article>

        <article class="info-card">
          <h3>Is a trustline safe?</h3>
          <p>
            XRPL trustlines permit your wallet to hold a token. They do not give anyone control
            of your funds or keys. Always verify issuer details before signing.
          </p>
        </article>

        <article class="info-card">
          <h3>How do I trade JCS?</h3>
          <p>
            Trade JCS through XRPL DEX interfaces that show the correct issuer.
            Use the official Sologenic and XPMarket links here to reduce impersonation risk.
          </p>
        </article>

        <article class="info-card">
          <h3>Is this financial advice?</h3>
          <p>
            No. JCS is a symbolic and utility-focused project for believers.
            Prices are volatile. Seek wisdom, pray, and follow your own informed conviction.
          </p>
        </article>

        <article class="info-card">
          <h3>What is the long-term vision?</h3>
          <p>
            Persistent Gospel witness on-ledger, transparent giving mechanics,
            Christ-centered content, and community tools that keep Jesus‚Äô words
            visible in a digital age.
          </p>
        </article>
      </div>
    </div>
  </section>
</main>

<!-- FOOTER -->
<footer>
  <div class="container">
    <div class="small" style="display:grid;gap:18px;grid-template-columns:1fr;max-width:var(--wrap);margin:0 auto;">

      <section>
        <h3>About this portal</h3>
        <p class="hint">
          This page is a non-custodial trading, monitoring, and diagnostics interface for
          <strong>Jesus Christ Saves (JCS)</strong> on the <span class="nowrap">XRP Ledger</span>.
          All transactions are prepared client-side and must be signed in your own Xaman wallet.
        </p>
        <dl class="factlist" aria-label="JCS details" style="display:grid;gap:6px;margin:0;padding:0;">
          <div class="fact" style="display:flex;gap:8px">
            <strong style="min-width:142px;color:#cfe6ff">Symbol</strong>
            <span class="mono">JCS</span>
          </div>
          <div class="fact" style="display:flex;gap:8px">
            <strong style="min-width:142px;color:#cfe6ff">Issuer</strong>
            <span class="mono">rPU6sXCNzsjcTUEmgJQ5SxDUzY2y1RyYKd</span>
          </div>
          <div class="fact" style="display:flex;gap:8px">
            <strong style="min-width:142px;color:#cfe6ff">Currency HEX</strong>
            <span class="mono">4A43530000000000000000000000000000000000</span>
          </div>
          <div class="fact" style="display:flex;gap:8px">
            <strong style="min-width:142px;color:#cfe6ff">Portal URL</strong>
            <span class="mono">https://jesuschristsavestoken.com/</span>
          </div>
        </dl>
      </section>

      <section>
        <h3>How this page handles security</h3>
        <ul class="small" style="margin:0;padding-left:18px;line-height:1.5;text-align:left;max-width:720px;">
          <li><strong>Non-custodial.</strong> No secret keys, seeds, or recovery phrases are requested or stored.</li>
          <li><strong>Wallet-side signing only.</strong> Transactions are constructed in the browser and signed in Xaman.</li>
          <li><strong>Sentinel memo codes.</strong> 6-digit codes in memos let you match on-page intent with Xaman payloads.</li>
          <li><strong>On-ledger data only.</strong> Order books, AMM reads, and health checks query XRPL infrastructure.</li>
        </ul>
      </section>

      <section>
        <h3>JCS Official Links</h3>
        <p class="hint">
          Use only these verified entry points when exploring Jesus Christ Saves Token on the XRP Ledger.
        </p>
        <div style="display:flex;flex-wrap:wrap;gap:10px;margin-top:6px;">
          <a href="https://jesuschristsavestoken.com/" class="eco-link">
            <img src="https://jesuschristsavestoken.com/jcs-logo.png" alt="Jesus Christ Saves Token logo">
            <span>Official JCS Website</span>
          </a>

          <a href="https://sologenic.org/trade?market=JCS%2BrPU6sXCNzsjcTUEmgJQ5SxDUzY2y1RyYKd%2FXRP" class="eco-link" target="_blank" rel="noopener">
            <img src="https://jesuschristsavestoken.com/jcs-logo.png" alt="Sologenic JCS/XRP">
            <span>Sologenic: JCS/XRP Market</span>
          </a>

          <a href="https://sologenic.org/amm/JCS_XRP_rPU6sXCNzsjcTUEmgJQ5SxDUzY2y1RyYKd" class="eco-link" target="_blank" rel="noopener">
            <img src="https://jesuschristsavestoken.com/jcs-logo.png" alt="Sologenic JCS AMM">
            <span>Sologenic: JCS-XRP AMM</span>
          </a>

          <a href="https://xpmarket.com/token/JCS-rPU6sXCNzsjcTUEmgJQ5SxDUzY2y1RyYKd" class="eco-link" target="_blank" rel="noopener">
            <img src="https://jesuschristsavestoken.com/jcs-logo.png" alt="XPMarket JCS">
            <span>XPMarket: JCS Listing</span>
          </a>

          <a href="https://x.com/JesusCS_token" target="_blank" class="eco-link" rel="noopener">
            <img src="https://upload.wikimedia.org/wikipedia/commons/6/6f/Logo_of_Twitter.svg"
                 alt="Twitter">
            <span>@JesusCS_token</span>
          </a>
        </div>
      </section>
    </div>

    <div class="small"
         style="border-top:1px solid var(--line);margin-top:14px;padding-top:10px;display:flex;flex-wrap:wrap;gap:12px;justify-content:space-between;align-items:flex-start">

      <div style="display:flex;flex-direction:column;gap:4px;min-width:220px">
        <strong>Jesus Christ Saves (JCS) ¬∑ JCS/XRP Trading & Sentinel Portal</strong>
        <span class="mono">Issuer: rPU6sXCNzsjcTUEmgJQ5SxDUzY2y1RyYKd</span>
        <span class="mono">Currency HEX: 4A43530000000000000000000000000000000000</span>
        <span class="mono">Network: XRPL Mainnet</span>
      </div>

      <div style="flex:1;min-width:260px">
        <ul style="margin:0;padding-left:18px;line-height:1.45">
          <li><strong>Not financial advice.</strong> Perform independent checks.</li>
          <li><strong>Non-custodial.</strong> You control your wallet; signing happens only in Xaman.</li>
          <li><strong>On-ledger risk.</strong> XRPL transactions are final; verify issuer, asset, and amounts.</li>
          <li><strong>Verify the URL.</strong> Only use the portal URL published by the issuer.</li>
          <li><strong>No endorsement implied.</strong> ‚ÄúXRP‚Äù is by Ripple Labs, Inc.; ‚ÄúXaman (Xumm)‚Äù is by XRPL Labs.</li>
        </ul>
      </div>

      <div style="min-width:160px;display:flex;flex-direction:column;gap:4px;align-items:flex-end">
        <a href="#top" class="eco-link">
          <img src="./jcs-logo.png" alt="JCS logo">
          <span>Back to top</span>
        </a>
      </div>
    </div>
  </div>
</footer>

<!-- App configuration for JCS XRPL portal (TEST endpoint) -->
<script type="application/json" id="app-config">
{
  "proxyUrl": "https://xrbitcoincash-github-io.onrender.com",
  "xummApiKey": "9f853ecf-d95f-4e03-8591-e41f91b9f3c5",
  "appName": "JCS XRPL Portal (TEST)",
  "asset": {
    "issuer": "rPU6sXCNzsjcTUEmgJQ5SxDUzY2y1RyYKd",
    "currencyHex": "4A43530000000000000000000000000000000000"
  }
}
</script>


<!-- Xaman / Xumm SDK -->
<script src="https://xaman.app/assets/cdn/xumm.min.js" crossorigin="anonymous"></script>

<!-- Main portal script (unchanged logic, minor ID rename for portalMetrics) -->
<script>
(function () {
  'use strict';

  function safeJson(elId) {
    try {
      const el = document.getElementById(elId);
      if (!el) return {};
      return JSON.parse(el.textContent || el.innerText || '{}') || {};
    } catch {
      return {};
    }
  }

  const cfg = safeJson('app-config');

  function resolveProxyBase() {
    const fromCfg = (cfg.proxyUrl || '').trim();
    if (fromCfg) return fromCfg.replace(/\/+$/, '');
    const origin = (location && location.origin) || '';
    const host = (location && location.hostname) || '';
    if (/xrbitcoincash/i.test(host) || /xrbitcoin/i.test(host)) {
      return 'https://xrbitcoincash-github-io.onrender.com';
    }
    return origin ? origin + '/xrpl-proxy' : '';
  }

  const PROXY_BASE = resolveProxyBase();
  const XUMM_API_KEY = (cfg.xummApiKey || '').trim();
  const ASSET = cfg.asset || {};
  const CURRENCY_HEX = String(ASSET.currencyHex || '').toUpperCase();
  const ISSUER = (ASSET.issuer || '').trim();

  const XRP_TO_DROPS = 1000000;
  const SLIPPAGE_PCT = 2;
  const RESERVE_BUFFER_XRP = 1.0;

  if (!PROXY_BASE) console.warn('Proxy URL missing');
  if (!ISSUER || !CURRENCY_HEX) console.warn('Asset config missing');

  const $ = id => document.getElementById(id);

  const walletStatus = $('walletStatus');
  const trustlineMsg = $('trustlineMsg');
  const connectBtn = $('connectWalletBtn');
  const disconnectBtn = $('disconnectWalletBtn');
  const setTrustBtn = $('setTrustlineBtn');
  const logEl = $('log');
  const resultBox = $('resultBox');

  function log(msg) {
    if (!logEl) return;
    logEl.textContent += msg + '\n';
    logEl.scrollTop = logEl.scrollHeight;
  }

  function setStatus(el, msg, cls) {
    if (!el) return;
    el.textContent = msg;
    el.classList.remove('ok', 'err');
    if (cls) el.classList.add(cls);
    if (el === walletStatus) log('[wallet] ' + msg);
    if (el === $('tradeMsg')) log('[trade] ' + msg);
    if (el === $('offersStatus')) log('[offers] ' + msg);
    if (el === $('healthStatus')) log('[health] ' + msg);
    if (el === $('buyStatus')) log('[buy] ' + msg);
  }

  function setResult(msg) {
    if (!resultBox) return;
    resultBox.textContent = msg;
    log('[result] ' + msg);
  }

  function toDrops(xrp) {
    return Math.round(Number(xrp) * XRP_TO_DROPS).toString();
  }

  function genCode() {
    return String(Math.floor(Math.random() * 1000000)).padStart(6, '0');
  }

  function asciiToHex(str) {
    let out = '';
    for (let i = 0; i < str.length; i++) {
      const h = str.charCodeAt(i).toString(16).toUpperCase();
      out += (h.length === 1 ? '0' : '') + h;
    }
    return out;
  }

  function hexToAsciiSymbol(hex) {
    if (!hex) return '';
    let out = '';
    for (let i = 0; i < hex.length; i += 2) {
      const b = parseInt(hex.slice(i, i + 2), 16);
      if (!Number.isFinite(b) || b <= 0) break;
      out += String.fromCharCode(b);
    }
    return out.replace(/[^\x20-\x7E]/g, '');
  }

  function nowIso() {
    try { return new Date().toISOString(); } catch { return ''; }
  }

  function originForMemo() {
    try { return location.origin + location.pathname; } catch { return ''; }
  }

  /* Known token meta */
  const TOKEN_META = {
    '4A43530000000000000000000000000000000000': {
      ticker: 'JCS',
      logo: './jcs-logo.png'
    },
    '5852626974636F696E6361736800000000000000': {
      ticker: 'XRBitcoinCash',
      logo: './xrbitcoincash-favicon.png'
    }
  };

  function decodeCurrencyHex(hex) {
    if (!hex) return null;
    let trimmed = hex.replace(/0+$/,'');
    if (!trimmed || trimmed.length % 2 !== 0) return null;
    let out = '';
    for (let i = 0; i < trimmed.length; i += 2) {
      const code = parseInt(trimmed.slice(i, i + 2), 16);
      if (!Number.isFinite(code) || code < 0x21 || code > 0x7E) return null;
      out += String.fromCharCode(code);
    }
    if (!out.trim()) return null;
    if (out.length > 12) return null;
    return out;
  }

  function getDisplayTicker(hex, issuer) {
    if (!hex) return 'IOU';
    const meta = TOKEN_META[hex];
    if (meta && meta.ticker) return meta.ticker;
    const decoded = decodeCurrencyHex(hex);
    if (decoded) return decoded;
    return hex.slice(0, 6);
  }

  function iconUrlForToken(hex, issuer) {
    const meta = TOKEN_META[hex];
    if (meta && meta.logo) return meta.logo;
    const label = (getDisplayTicker(hex, issuer) || '?').slice(0, 4);
    const svg =
      '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">' +
        '<rect width="16" height="16" rx="3" fill="#020817"/>' +
        '<text x="50%" y="55%" font-size="6" text-anchor="middle" fill="#38bdf8" font-family="system-ui, -apple-system, sans-serif">' +
        label +
        '</text>' +
      '</svg>';
    return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
  }

  const CURRENCY_ASCII = hexToAsciiSymbol(CURRENCY_HEX);
  const APP_NAME = (cfg.appName || CURRENCY_ASCII || 'JCS').trim() || 'JCS';

  const SENTINEL_PREFIX = (cfg.sentinelPrefix ||
    (APP_NAME.toUpperCase().replace(/[^A-Z0-9]/g,'').slice(0,6) || 'ASSET')).toUpperCase();

  const SENTINEL_VERSION = 'v1';

  function appIdFromPath(p) {
    try {
      const name = (p || location.pathname).split('/').filter(Boolean).pop() || 'index.html';
      return APP_NAME + ':' + name;
    } catch {
      return APP_NAME + ':index';
    }
  }

  function buildSentinelMemos(code) {
    const ctx = {
      v: SENTINEL_VERSION,
      ts: nowIso(),
      origin: originForMemo(),
      app_id: appIdFromPath(location.pathname)
    };
    return [
      { Memo: { MemoType: asciiToHex(SENTINEL_PREFIX + '-SENT'), MemoData: asciiToHex(code) } },
      { Memo: { MemoType: asciiToHex(SENTINEL_PREFIX + '-CTX'),  MemoData: asciiToHex(JSON.stringify(ctx)) } }
    ];
  }

  function setSecurityCodeDisplay(code) {
    const el = $('xrbSecurityCode');
    if (!el) return;
    if (code) {
      el.textContent = 'Xaman security code: ' + code;
      el.style.display = '';
    } else {
      el.textContent = '';
      el.style.display = 'none';
    }
  }

  async function xrplRequest(payload, { timeoutMs = 15000 } = {}) {
    if (!PROXY_BASE) throw new Error('Proxy URL missing');
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const res = await fetch(PROXY_BASE, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        mode: 'cors',
        cache: 'no-store',
        credentials: 'omit',
        body: JSON.stringify(payload),
        signal: ctrl.signal
      });
      if (!res.ok) throw new Error('Proxy HTTP ' + res.status);
      const data = await res.json();
      let envelope;
      if (data && typeof data === 'object' && 'result' in data) envelope = data;
      else envelope = { result: data };
      const r = envelope.result || {};
      if (r && (r.error || r.error_message)) {
        throw new Error(r.error_message || r.error || 'XRPL error');
      }
      return envelope;
    } finally {
      clearTimeout(t);
    }
  }

  async function call(method, params) {
    const base = { ...(params || {}), ledger_index: 'validated' };
    const r = await xrplRequest({ method, params: [base] });
    return r.result;
  }

  let xumm = null;
  let currentAccount = null;
  let HAS_TRUSTLINE = false;

  function updateWalletButtons() {
    const connected = !!currentAccount;
    if (connectBtn) connectBtn.disabled = connected;
    if (disconnectBtn) disconnectBtn.disabled = !connected;
    if (setTrustBtn) setTrustBtn.disabled = !connected || HAS_TRUSTLINE;
    const allowTrade = connected && HAS_TRUSTLINE;
    if ($('placeOfferBtn')) $('placeOfferBtn').disabled = !allowTrade;
    if ($('marketTradeBtn')) $('marketTradeBtn').disabled = !allowTrade;
    if ($('btnHealthScan')) $('btnHealthScan').disabled = !connected;
  }

  async function checkTrustline(acct) {
    try {
      const r = await xrplRequest({
        method: 'account_lines',
        params: [{ account: acct, peer: ISSUER, ledger_index: 'validated', limit: 400 }]
      });
      const lines = (r.result && r.result.lines) || [];
      return lines.some(l => {
        const cur = (l.currency || '').toUpperCase();
        return cur === CURRENCY_HEX;
      });
    } catch {
      return false;
    }
  }

  async function refreshTrustline() {
    if (!currentAccount) {
      HAS_TRUSTLINE = false;
      updateWalletButtons();
      return;
    }
    HAS_TRUSTLINE = await checkTrustline(currentAccount);
    if (HAS_TRUSTLINE) {
      setStatus(trustlineMsg, APP_NAME + ' trustline present.', 'ok');
    } else {
      setStatus(trustlineMsg, APP_NAME + ' trustline not found. Use ‚ÄúAdd ' + APP_NAME + ' Trust Line‚Äù.');
    }
    updateWalletButtons();
  }

  function setConnected(acct) {
    currentAccount = acct;
    window.__xrbWallet = acct;
    try { localStorage.setItem('xrbWallet', acct); } catch {}
    setStatus(walletStatus, 'Connected: ' + acct, 'ok');
    updateWalletButtons();
    refreshTrustline().catch(() => {});
    refreshAll().catch(() => {});
  }

  function setDisconnected() {
    currentAccount = null;
    window.__xrbWallet = null;
    try { localStorage.removeItem('xrbWallet'); } catch {}
    HAS_TRUSTLINE = false;
    setStatus(walletStatus, 'Status: Not connected');
    setStatus(trustlineMsg, '');
    updateWalletButtons();
  }

if (typeof Xumm !== 'undefined' && XUMM_API_KEY) {
xumm = new Xumm(XUMM_API_KEY);

```
// Wait for SDK to be ready
xumm.on('ready', async () => {
    let acct = null;
    try {
        acct = await xumm.user.account;
    } catch {}

    // Restore from localStorage if no account
    if (!acct) {
        try { acct = localStorage.getItem('xrbWallet'); } catch {}
    }

    if (acct) {
        setConnected(acct);
    } else {
        updateWalletButtons();
    }
});

// Handle returning focus (mobile deep link support)
window.addEventListener('focus', async () => {
    if (!xumm) return;
    try {
        const acct = await xumm.user.account;
        if (acct) setConnected(acct);
    } catch {}
});

// Connect wallet button
if (connectBtn) {
    connectBtn.addEventListener('click', async () => {
        if (currentAccount) {
            setStatus(walletStatus, 'Already connected: ' + currentAccount);
            return;
        }
        setStatus(walletStatus, 'Waiting for Xaman...');
        try {
            await xumm.authorize();
            const acct = await xumm.user.account;
            if (acct) setConnected(acct);
            else setStatus(walletStatus, 'Connect canceled or no account', 'err');
        } catch (e) {
            setStatus(walletStatus, 'Connect failed: ' + (e.message || e), 'err');
        }
    });
}

// Disconnect wallet button
if (disconnectBtn) {
    disconnectBtn.addEventListener('click', () => {
        try { xumm.logout(); } catch {}
        setDisconnected();
    });
}
```

} else {
if (walletStatus) setStatus(walletStatus, 'Xaman SDK not loaded; wallet features disabled.', 'err');
if (connectBtn) connectBtn.disabled = true;
if (setTrustBtn) setTrustBtn.disabled = true;
}


    window.addEventListener('focus', () => {
      if (!xumm) return;
      xumm.user.account.then(a => { if (a) setConnected(a); }).catch(() => {});
    });

    if (connectBtn) {
      connectBtn.addEventListener('click', async () => {
        try {
          if (currentAccount) {
            setStatus(walletStatus, 'Already connected: ' + currentAccount);
            return;
          }
          setStatus(walletStatus, 'Waiting for Xaman');
          await xumm.authorize();
          const acct = await xumm.user.account;
          if (acct) setConnected(acct);
          else setStatus(walletStatus, 'Connect canceled or no account', 'err');
        } catch (e) {
          setStatus(walletStatus, 'Connect failed: ' + (e.message || e), 'err');
        }
      });
    }

    if (disconnectBtn) {
      disconnectBtn.addEventListener('click', () => {
        try { xumm.logout(); } catch {}
        setDisconnected();
      });
    }

    if (setTrustBtn) {
      setTrustBtn.addEventListener('click', async () => {
        try {
          if (!currentAccount) {
            setStatus(trustlineMsg, 'Connect wallet first.', 'err');
            return;
          }
          setTrustBtn.disabled = true;

          const exists = await checkTrustline(currentAccount);
          if (exists) {
            HAS_TRUSTLINE = true;
            setStatus(trustlineMsg, APP_NAME + ' trustline already present.', 'ok');
            updateWalletButtons();
            return;
          }

          const code = genCode();
          const txjson = {
            TransactionType: 'TrustSet',
            Account: currentAccount,
            LimitAmount: { currency: CURRENCY_HEX, issuer: ISSUER, value: '1000000000' },
            Memos: buildSentinelMemos(code)
          };

          setStatus(walletStatus, 'Verify code: ' + code + ' in Xaman memos.');

          const { created, resolved } = await xumm.payload.createAndSubscribe(
            {
              txjson,
              options: { submit: true, expire: 300 },
              custom_meta: {
                instruction: 'Verify code ' + code + ' and details, then sign.',
                identifier: 'sentinel:trust:' + code
              }
            },
            e => {
              if (e?.opened) setStatus(trustlineMsg, 'Open Xaman or scan QR to review.');
              if (e?.signed === false) setStatus(trustlineMsg, 'Trustline rejected.', 'err');
            }
          );

          const sec = created?.meta?.security_code || created?.meta?.securityCode || null;
          setSecurityCodeDisplay(sec || code);

          const res = await resolved;
          setSecurityCodeDisplay(null);

          if (!res?.signed) {
            setStatus(trustlineMsg, 'Trustline not signed.', 'err');
            return;
          }

          setStatus(trustlineMsg, 'Trustline set. Wait for validation.', 'ok');
          HAS_TRUSTLINE = true;
          updateWalletButtons();
          refreshAll().catch(() => {});
        } catch (e) {
          setSecurityCodeDisplay(null);
          setStatus(trustlineMsg, 'Trustline error: ' + (e.message || e), 'err');
        } finally {
          setTrustBtn.disabled = !currentAccount || HAS_TRUSTLINE;
        }
      });
    }
  } else {
    if (walletStatus) setStatus(walletStatus, 'Xaman SDK not loaded; wallet features disabled.', 'err');
    if (connectBtn) connectBtn.disabled = true;
    if (setTrustBtn) setTrustBtn.disabled = true;
  }

  async function signWithSentinel(baseTx, purpose) {
    if (!xumm) throw new Error('Wallet SDK not available');
    const acct = currentAccount || await xumm.user.account;
    if (!acct) throw new Error('Connect wallet first');

    const code = genCode();
    const memos = buildSentinelMemos(code);
    const txjson = { Account: acct, ...baseTx, Memos: [ ...(baseTx.Memos || []), ...memos ] };

    setStatus(walletStatus, 'Verify code: ' + code + ' in Xaman memos.');

    const { created, resolved } = await xumm.payload.createAndSubscribe(
      {
        txjson,
        options: { submit: true, expire: 300 },
        custom_meta: {
          instruction: 'Verify code ' + code + ' and details, then sign.',
          identifier: 'sentinel:' + purpose + ':' + code
        }
      },
      e => {
        if (e?.opened) setStatus($('tradeMsg'), 'Payload opened in Xaman.');
        if (e?.signed === false) setStatus($('tradeMsg'), 'Action rejected.', 'err');
      }
    );

    const sec = created?.meta?.security_code || created?.meta?.securityCode || null;
    setSecurityCodeDisplay(sec || code);

    const res = await resolved;
    setSecurityCodeDisplay(null);

    if (!res?.signed) throw new Error('Not signed');
    return res;
  }

  const sideEl = $('side');
  const buyTab = $('buyTab');
  const sellTab = $('sellTab');
  const amountEl = $('amount');
  const priceEl = $('price');
  const totalXrpEl = $('totalXrp');
  const suggestBtn = $('suggestPriceBtn');
  const placeOfferBtn = $('placeOfferBtn');
  const marketBtn = $('marketTradeBtn');
  const tradeMsg = $('tradeMsg');

  function updateExplainer(side) {
    const buyNote = document.querySelector('#sideExplain .note.buy');
    const sellNote = document.querySelector('#sideExplain .note.sell');
    const hint = $('amountHint');
    if (side === 'buy') {
      if (buyNote) buyNote.hidden = false;
      if (sellNote) sellNote.hidden = true;
      if (hint) hint.innerHTML =
        'Amount to <span id="actionWord">buy</span>. You trade XRP to receive ' + APP_NAME + '.';
    } else {
      if (buyNote) buyNote.hidden = true;
      if (sellNote) sellNote.hidden = false;
      if (hint) hint.innerHTML =
        'Amount to <span id="actionWord">sell</span>. You trade ' + APP_NAME + ' to receive XRP.';
    }
  }

  function setSide(side) {
    if (sideEl) sideEl.value = side;
    if (buyTab) {
      buyTab.classList.toggle('active', side === 'buy');
      buyTab.setAttribute('aria-selected', side === 'buy' ? 'true' : 'false');
    }
    if (sellTab) {
      sellTab.classList.toggle('active', side === 'sell');
      sellTab.setAttribute('aria-selected', side === 'sell' ? 'true' : 'false');
    }
    const tradeCard = $('trade');
    if (tradeCard) {
      tradeCard.classList.toggle('buy', side === 'buy');
      tradeCard.classList.toggle('sell', side === 'sell');
    }
    updateExplainer(side);
    recalcTotals();
  }

  function recalcTotals() {
    if (!totalXrpEl) return;
    const amt = Number(amountEl && amountEl.value) || 0;
    const px = Number(priceEl && priceEl.value) || 0;
    const total = px * amt;
    totalXrpEl.textContent = (isFinite(total) ? total : 0).toFixed(6) + ' XRP';
  }

  if (buyTab) buyTab.addEventListener('click', () => setSide('buy'));
  if (sellTab) sellTab.addEventListener('click', () => setSide('sell'));
  setSide('buy');

  if (amountEl) amountEl.addEventListener('input', recalcTotals);
  if (priceEl) priceEl.addEventListener('input', recalcTotals);

  const BAL = { xrp: 0, xrb: 0 };

  async function fetchBalances() {
    if (!currentAccount) {
      BAL.xrp = 0;
      BAL.xrb = 0;
      return BAL;
    }
    try {
      const info = await call('account_info', { account: currentAccount });
      BAL.xrp = Number(info.account_data.Balance || 0) / XRP_TO_DROPS;
    } catch {
      BAL.xrp = 0;
    }
    try {
      const r = await xrplRequest({
        method: 'account_lines',
        params: [{ account: currentAccount, peer: ISSUER, ledger_index: 'validated' }]
      });
      const lines = (r.result && r.result.lines) || [];
      const tl = lines.find(l => (l.currency || '').toUpperCase() === CURRENCY_HEX);
      BAL.xrb = tl ? Math.max(0, Number(tl.balance || 0)) : 0;
    } catch {
      BAL.xrb = 0;
    }
    return BAL;
  }

  (function initPercentChips() {
    const chips = document.querySelectorAll('.quick-amounts .qa');
    if (!chips.length) return;
    chips.forEach(btn => {
      btn.addEventListener('click', async () => {
        const pct = Number(btn.dataset.q || 0);
        if (!pct || !currentAccount) return;
        btn.disabled = true;
        try {
          const side = sideEl.value;
          await fetchBalances();
          if (side === 'sell') {
            const amt = BAL.xrb * (pct / 100);
            if (amountEl) {
              amountEl.value = amt.toFixed(6);
              recalcTotals();
            }
          } else {
            let px = Number(priceEl && priceEl.value) || 0;
            if (!px) {
              await fillBestPrice();
              px = Number(priceEl && priceEl.value) || 0;
            }
            if (!px) return;
            const spendable = Math.max(0, BAL.xrp - RESERVE_BUFFER_XRP) * (pct / 100);
            const amt = spendable > 0 ? spendable / px : 0;
            if (amt > 0 && amountEl) {
              amountEl.value = amt.toFixed(6);
              recalcTotals();
            }
          }
        } finally {
          btn.disabled = false;
        }
      });
    });
  })();

  async function getTopOfBook() {
    const [askRes, bidRes] = await Promise.all([
      xrplRequest({
        method: 'book_offers',
        params: [{
          taker_gets: { currency: CURRENCY_HEX, issuer: ISSUER },
          taker_pays: { currency: 'XRP' },
          limit: 5
        }]
      }),
      xrplRequest({
        method: 'book_offers',
        params: [{
          taker_gets: { currency: 'XRP' },
          taker_pays: { currency: CURRENCY_HEX, issuer: ISSUER },
          limit: 5
        }]
      })
    ]);

    function priceFrom(of) {
      if (!of) return null;
      const gets = of.TakerGets.value ? Number(of.TakerGets.value)
        : Number(of.TakerGets) / XRP_TO_DROPS;
      const pays = of.TakerPays.value ? Number(of.TakerPays.value)
        : Number(of.TakerPays) / XRP_TO_DROPS;
      if (!isFinite(gets) || gets <= 0 || !isFinite(pays)) return null;
      return pays / gets;
    }

    return {
      bestAsk: priceFrom((askRes.result.offers || [])[0]) || null,
      bestBid: priceFrom((bidRes.result.offers || [])[0]) || null
    };
  }

  async function getMarketPrice(side) {
    try {
      const ammWrap = await xrplRequest({
        method: 'amm_info',
        params: [{ asset: { currency: 'XRP' }, asset2: { currency: CURRENCY_HEX, issuer: ISSUER } }]
      });
      const amm = ammWrap.result.amm;
      if (amm && amountEl) {
        const amt = Number(amountEl.value);
        const reserveXrp = Number(amm.amount) / XRP_TO_DROPS;
        const reserveTok = Number(amm.amount2.value);
        const feeRate = (amm.trading_fee || 0) / 1000000;
        const k = reserveXrp * reserveTok;
        if (amt > 0 && reserveXrp > 0 && reserveTok > 0) {
          if (side === 'buy') {
            const newTok = reserveTok - amt;
            if (newTok > 0) {
              const newXrp = k / newTok;
              let xrpIn = newXrp - reserveXrp;
              xrpIn += xrpIn * feeRate;
              return xrpIn / amt;
            }
          } else {
            const newTok = reserveTok + amt;
            const newXrp = k / newTok;
            let xrpOut = reserveXrp - newXrp;
            xrpOut -= xrpOut * feeRate;
            if (amt > 0) return xrpOut / amt;
          }
        }
      }
    } catch {}
    const { bestAsk, bestBid } = await getTopOfBook();
    return side === 'buy' ? bestAsk : bestBid;
  }

  async function fillBestPrice() {
    if (!amountEl || !priceEl) return;
    const side = sideEl.value;
    const amt = Number(amountEl.value);
    if (!amt || amt <= 0) return;
    setStatus(tradeMsg, 'Querying XRPL for best price.');
    try {
      const px = await getMarketPrice(side);
      if (!px || px <= 0) throw new Error('No price available');
      priceEl.value = Number(px).toFixed(6);
      recalcTotals();
      setStatus(tradeMsg, 'Best price applied (' + side + ').', 'ok');
    } catch (e) {
      setStatus(tradeMsg, 'Price helper error: ' + (e.message || e), 'err');
    }
  }

  if (suggestBtn) suggestBtn.addEventListener('click', () => fillBestPrice());
  setInterval(() => {
    const amt = Number(amountEl && amountEl.value);
    if (amt > 0) fillBestPrice().catch(() => {});
  }, 10000);

  if (placeOfferBtn) {
    placeOfferBtn.addEventListener('click', async () => {
      try {
        if (!currentAccount) throw new Error('Connect wallet first');
        if (!HAS_TRUSTLINE) throw new Error('Add ' + APP_NAME + ' trustline first');
        const side = sideEl.value;
        const amt = Number(amountEl.value);
        const px = Number(priceEl.value);
        if (!amt || !px || amt <= 0 || px <= 0) throw new Error('Enter Amount and Price');
        const xrpTotal = px * amt;
        let tx;
        if (side === 'sell') {
          tx = {
            TransactionType: 'OfferCreate',
            TakerGets: { currency: CURRENCY_HEX, issuer: ISSUER, value: String(amt) },
            TakerPays: toDrops(xrpTotal),
            Flags: 0x00080000
          };
        } else {
          tx = {
            TransactionType: 'OfferCreate',
            TakerGets: toDrops(xrpTotal),
            TakerPays: { currency: CURRENCY_HEX, issuer: ISSUER, value: String(amt) },
            Flags: 0
          };
        }
        setStatus(tradeMsg, 'Open Xaman to review limit order.');
        await signWithSentinel(tx, 'offer');
        setStatus(tradeMsg, 'Order submitted.', 'ok');
        setResult('Limit order placed.');
        await refreshAll();
      } catch (e) {
        setStatus(tradeMsg, 'Error: ' + (e.message || e), 'err');
      }
    });
  }

  if (marketBtn) {
    marketBtn.addEventListener('click', async () => {
      try {
        if (!currentAccount) throw new Error('Connect wallet first');
        if (!HAS_TRUSTLINE) throw new Error('Add ' + APP_NAME + ' trustline first');
        const side = sideEl.value;
        const amt = Number(amountEl.value);
        if (!amt || amt <= 0) throw new Error('Enter Amount');
        const basePx = await getMarketPrice(side);
        if (!basePx || basePx <= 0) throw new Error('No market price');
        const slip = SLIPPAGE_PCT / 100;
        const TF_PARTIAL = 0x00020000;

        async function findPaths(params) {
          const r = await xrplRequest({ method: 'ripple_path_find', params: [params] });
          return r.result.alternatives || [];
        }

        function pickCheapestXrp(alts) {
          let best = null, bestDrops = Infinity;
          for (const alt of alts) {
            const sa = alt.source_amount;
            let drops = Infinity;
            if (typeof sa === 'string') drops = Number(sa);
            else if (sa && sa.currency === 'XRP') drops = Math.round(Number(sa.value) * XRP_TO_DROPS);
            if (isFinite(drops) && drops < bestDrops) { bestDrops = drops; best = alt; }
          }
          if (!best) throw new Error('No XRP path');
          return { best, drops: bestDrops };
        }

        function pickCheapestIOU(alts) {
          let best = null, bestVal = Infinity;
          for (const alt of alts) {
            const sa = alt.source_amount;
            if (sa && sa.currency === CURRENCY_HEX && sa.issuer === ISSUER) {
              const v = Number(sa.value);
              if (isFinite(v) && v < bestVal) { bestVal = v; best = alt; }
            }
          }
          if (!best) throw new Error('No ' + APP_NAME + ' path');
          return { best, val: bestVal };
        }

        let tx;

        if (side === 'buy') {
          const destAmt = { currency: CURRENCY_HEX, issuer: ISSUER, value: String(amt) };
          const alts = await findPaths({
            source_account: currentAccount,
            destination_account: currentAccount,
            destination_amount: destAmt,
            source_currencies: [{ currency: 'XRP' }]
          });
          const { best, drops } = pickCheapestXrp(alts);
          const maxDrops = Math.ceil(drops * (1 + slip));
          tx = {
            TransactionType: 'Payment',
            Destination: currentAccount,
            Amount: destAmt,
            SendMax: String(maxDrops),
            Flags: TF_PARTIAL,
            DeliverMin: {
              currency: CURRENCY_HEX,
              issuer: ISSUER,
              value: (amt * (1 - slip)).toFixed(6)
            },
            Paths: best.paths_computed || best.paths_canonical || []
          };
        } else {
          const estXrp = amt * basePx;
          const minXrpDrops = Math.floor(estXrp * (1 - slip) * XRP_TO_DROPS);
          if (minXrpDrops < 1) throw new Error('Amount too small after slippage');
          const alts = await findPaths({
            source_account: currentAccount,
            destination_account: currentAccount,
            destination_amount: String(minXrpDrops),
            source_currencies: [{ currency: CURRENCY_HEX, issuer: ISSUER }]
          });
          const { best, val } = pickCheapestIOU(alts);
          if (val > amt) throw new Error('Increase amount for slippage cap');
          tx = {
            TransactionType: 'Payment',
            Destination: currentAccount,
            Amount: String(minXrpDrops),
            SendMax: { currency: CURRENCY_HEX, issuer: ISSUER, value: String(amt) },
            Flags: TF_PARTIAL,
            DeliverMin: String(minXrpDrops),
            Paths: best.paths_computed || best.paths_canonical || []
          };
        }

        setStatus(tradeMsg, 'Open Xaman to review market swap.');
        await signWithSentinel(tx, 'swap');
        setStatus(tradeMsg, 'Swap submitted.', 'ok');
        setResult('Market swap submitted.');
        await refreshAll();
      } catch (e) {
        setStatus(tradeMsg, 'Error: ' + (e.message || e), 'err');
      }
    });
  }

  const offersWrap = $('offersWrap');
  const offersStatus = $('offersStatus');
  const offersProgress = $('offersProgress');
  const btnRefreshOffers = $('btnRefreshOffers');
  const btnCancelAll = $('btnCancelAll');

  function setOffersStatus(msg, cls) { setStatus(offersStatus, msg, cls); }
  function setOffersProgress(pct) {
    if (!offersProgress) return;
    const v = Math.max(0, Math.min(100, pct));
    offersProgress.style.width = v + '%';
  }

  async function fetchOffers(acct) {
    if (!acct) {
      setOffersStatus('Connect wallet first.', 'err');
      return;
    }
    setOffersStatus('Loading offers.');
    setOffersProgress(10);
    try {
      const r = await xrplRequest({
        method: 'account_offers',
        params: [{ account: acct, limit: 400 }]
      });
      const offers = (r.result && r.result.offers) || [];
      renderOffers(offers);
      setOffersStatus('Found ' + offers.length + ' open offer(s).', 'ok');
      setOffersProgress(100);
      setTimeout(() => setOffersProgress(0), 300);
    } catch (e) {
      renderOffers([]);
      setOffersStatus('Offers error: ' + (e.message || e), 'err');
      setOffersProgress(0);
    }
  }

  function renderOffers(offers) {
    if (!offersWrap) return;
    offersWrap.innerHTML = '';

    if (!offers || !offers.length) {
      offersWrap.textContent = 'No open offers found.';
      return;
    }

    // Only show offers touching our JCS/XRP pair
    function isJcsSide(v) {
      if (!v) return false;
      if (typeof v === 'string') return false; // XRP in drops
      const cur = String(v.currency || '').toUpperCase();
      const iss = String(v.issuer || '').trim();
      return cur === CURRENCY_HEX && iss === ISSUER;
    }
    function isXrpSide(v) {
      if (!v) return false;
      if (typeof v === 'string') return true;
      return String(v.currency || '').toUpperCase() === 'XRP';
    }

    const filtered = offers.filter(o => {
      const g = o.TakerGets;
      const p = o.TakerPays;
      const jcsSide = isJcsSide(g) || isJcsSide(p);
      const xrpSide = isXrpSide(g) || isXrpSide(p);
      return jcsSide && xrpSide;
    });

    if (!filtered.length) {
      offersWrap.textContent = 'No JCS/XRP offers found (other pairs may exist).';
      return;
    }

    const wrap = document.createElement('div');
    wrap.style.overflow = 'auto';

    const table = document.createElement('table');
    const thead = document.createElement('thead');
    const tbody = document.createElement('tbody');

    thead.innerHTML = `
      <tr>
        <th>Side</th>
        <th>Gets</th>
        <th>Pays</th>
        <th>Price (XRP/JCS)</th>
        <th>Seq</th>
        <th></th>
      </tr>
    `;

    function formatAmount(v) {
      if (typeof v === 'string') {
        return (Number(v) / XRP_TO_DROPS).toFixed(6) + ' XRP';
      }
      if (!v) return '‚Äî';
      const cur = String(v.currency || '').toUpperCase();
      const iss = String(v.issuer || '').trim();
      const ticker = getDisplayTicker(cur, iss);
      return Number(v.value || 0).toFixed(6) + ' ' + ticker;
    }

    function computePrice(o) {
      const g = o.TakerGets;
      const p = o.TakerPays;
      let getsXrp = isXrpSide(g);
      let paysXrp = isXrpSide(p);

      let getsValJcs = isJcsSide(g);
      let paysValJcs = isJcsSide(p);

      let xrp, jcs;

      if (getsXrp && paysValJcs) {
        xrp = typeof g === 'string'
          ? Number(g) / XRP_TO_DROPS
          : Number(g.value || 0);
        jcs = typeof p === 'string'
          ? Number(p) / XRP_TO_DROPS
          : Number(p.value || 0);
      } else if (getsValJcs && paysXrp) {
        xrp = typeof p === 'string'
          ? Number(p) / XRP_TO_DROPS
          : Number(p.value || 0);
        jcs = typeof g === 'string'
          ? Number(g) / XRP_TO_DROPS
          : Number(g.value || 0);
      } else {
        return null;
      }

      if (!isFinite(xrp) || !isFinite(jcs) || jcs <= 0) return null;
      return xrp / jcs;
    }

    filtered.forEach(o => {
      const tr = document.createElement('tr');

      const g = o.TakerGets;
      const p = o.TakerPays;
      const seq = o.seq || o.Sequence;

      let side = '‚Äî';
      if (isJcsSide(g) && isXrpSide(p)) side = 'Sell JCS';
      else if (isXrpSide(g) && isJcsSide(p)) side = 'Buy JCS';

      const price = computePrice(o);

      const sideTd = document.createElement('td');
      sideTd.textContent = side;

      const getsTd = document.createElement('td');
      getsTd.textContent = formatAmount(g);

      const paysTd = document.createElement('td');
      paysTd.textContent = formatAmount(p);

      const priceTd = document.createElement('td');
      priceTd.textContent = price ? price.toFixed(6) : '‚Äî';

      const seqTd = document.createElement('td');
      seqTd.textContent = String(seq || '‚Äî');

      const actTd = document.createElement('td');
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'btn small';
      btn.textContent = 'Cancel';
      btn.dataset.seq = String(seq);
      btn.addEventListener('click', () => cancelOffer(seq));
      actTd.appendChild(btn);

      tr.appendChild(sideTd);
      tr.appendChild(getsTd);
      tr.appendChild(paysTd);
      tr.appendChild(priceTd);
      tr.appendChild(seqTd);
      tr.appendChild(actTd);

      tbody.appendChild(tr);
    });

    table.appendChild(thead);
    table.appendChild(tbody);
    wrap.appendChild(table);
    offersWrap.appendChild(wrap);
  }

  async function cancelOffer(seq) {
    if (!currentAccount) {
      setOffersStatus('Connect wallet first.', 'err');
      return;
    }
    if (!seq && seq !== 0) return;
    try {
      setOffersStatus('Preparing cancel for sequence ' + seq + '‚Ä¶');
      const tx = {
        TransactionType: 'OfferCancel',
        OfferSequence: Number(seq)
      };
      await signWithSentinel(tx, 'cancel_offer');
      setOffersStatus('Cancel submitted for sequence ' + seq + '.', 'ok');
      setResult('Canceled offer sequence ' + seq + '.');
      await fetchOffers(currentAccount);
    } catch (e) {
      setOffersStatus('Cancel error: ' + (e.message || e), 'err');
    }
  }

  if (btnRefreshOffers) {
    btnRefreshOffers.addEventListener('click', () => {
      if (!currentAccount) {
        setOffersStatus('Connect wallet first.', 'err');
        return;
      }
      fetchOffers(currentAccount);
    });
  }

  if (btnCancelAll) {
    btnCancelAll.addEventListener('click', async () => {
      if (!currentAccount) {
        setOffersStatus('Connect wallet first.', 'err');
        return;
      }
      const seqButtons = offersWrap
        ? offersWrap.querySelectorAll('button[data-seq]')
        : [];
      if (!seqButtons.length) {
        setOffersStatus('No visible offers to cancel.', 'err');
        return;
      }
      const seqs = Array.from(seqButtons).map(b => Number(b.dataset.seq));
      setOffersStatus('Submitting cancels for ' + seqs.length + ' offers‚Ä¶');
      for (const s of seqs) {
        try {
          await cancelOffer(s);
        } catch {}
      }
      setOffersStatus('Bulk cancel completed.', 'ok');
      await fetchOffers(currentAccount);
    });
  }

  const xrbtcSpotEl = $('xrbtcSpot');
  const xrbtcAmmEl = $('xrbtcAmm');
  const xrbtcSpreadEl = $('xrbtcSpread');
  const xrbtcLedgerMiniEl = $('xrbtcLedgerMini');
  const priceOutputEl = $('priceOutput');
  const ledgerOutputEl = $('ledgerOutput');
  const ledgerPillEl = $('ledgerPill');

  async function refreshOrderBookAndLedger() {
    try {
      const [asksRes, bidsRes, ledgerRes] = await Promise.all([
        xrplRequest({
          method: 'book_offers',
          params: [{
            taker_gets: { currency: CURRENCY_HEX, issuer: ISSUER },
            taker_pays: { currency: 'XRP' },
            limit: 8
          }]
        }),
        xrplRequest({
          method: 'book_offers',
          params: [{
            taker_gets: { currency: 'XRP' },
            taker_pays: { currency: CURRENCY_HEX, issuer: ISSUER },
            limit: 8
          }]
        }),
        call('ledger', { ledger_index: 'validated', transactions: false, expand: false })
      ]);

      const asks = (asksRes.result && asksRes.result.offers) || [];
      const bids = (bidsRes.result && bidsRes.result.offers) || [];

      function priceFrom(of) {
        if (!of) return null;
        const gets = of.TakerGets.value ? Number(of.TakerGets.value)
          : Number(of.TakerGets) / XRP_TO_DROPS;
        const pays = of.TakerPays.value ? Number(of.TakerPays.value)
          : Number(of.TakerPays) / XRP_TO_DROPS;
        if (!isFinite(gets) || gets <= 0 || !isFinite(pays)) return null;
        return pays / gets;
      }

      const bestAsk = priceFrom(asks[0]) || null;
      const bestBid = priceFrom(bids[0]) || null;

      if (xrbtcSpotEl) {
        xrbtcSpotEl.textContent =
          'Spot: ' + (bestBid && bestAsk
            ? ((bestBid + bestAsk) / 2).toFixed(6) + ' XRP/JCS'
            : '‚Äî');
      }
      if (xrbtcSpreadEl) {
        if (bestBid && bestAsk) {
          const spreadPct = ((bestAsk - bestBid) / bestAsk) * 100;
          xrbtcSpreadEl.textContent =
            'Spread: ' + spreadPct.toFixed(3) + '%';
        } else {
          xrbtcSpreadEl.textContent = 'Spread: ‚Äî';
        }
      }

      if (priceOutputEl) {
        const lines = [];
        lines.push('Asks (sell JCS):');
        if (!asks.length) lines.push('  ‚Äî');
        asks.forEach((o, i) => {
          const px = priceFrom(o);
          const sz = o.TakerGets.value
            ? Number(o.TakerGets.value)
            : Number(o.TakerPays.value || 0);
          lines.push(
            '  ' +
            String(i + 1).padStart(2, ' ') +
            '  ' +
            (px ? px.toFixed(6) : '‚Äî') +
            ' XRP/JCS  ¬∑ size ' +
            (isFinite(sz) ? sz.toFixed(2) : '‚Äî')
          );
        });

        lines.push('');
        lines.push('Bids (buy JCS):');
        if (!bids.length) lines.push('  ‚Äî');
        bids.forEach((o, i) => {
          const px = priceFrom(o);
          const sz = o.TakerPays.value
            ? Number(o.TakerPays.value)
            : Number(o.TakerGets.value || 0);
          lines.push(
            '  ' +
            String(i + 1).padStart(2, ' ') +
            '  ' +
            (px ? px.toFixed(6) : '‚Äî') +
            ' XRP/JCS  ¬∑ size ' +
            (isFinite(sz) ? sz.toFixed(2) : '‚Äî')
          );
        });

        priceOutputEl.textContent = lines.join('\n');
      }

      const led = ledgerRes.ledger || {};
      const ledIndex = led.ledger_index || ledgerRes.ledger_index;
      const ledTime = led.close_time_human || led.close_time || '';
      if (ledgerOutputEl) {
        ledgerOutputEl.textContent = JSON.stringify({
          ledger_index: ledIndex,
          close_time: ledTime,
          tx_count: led.txn_count,
          total_coins: led.total_coins
        }, null, 2);
      }
      if (xrbtcLedgerMiniEl) {
        xrbtcLedgerMiniEl.textContent =
          'Ledger: ' + (ledIndex ? String(ledIndex) : '‚Äî');
      }
      if (ledgerPillEl) {
        ledgerPillEl.textContent =
          'Ledger: ' + (ledIndex ? String(ledIndex) : '‚Äî');
      }

      try {
        const ammWrap = await xrplRequest({
          method: 'amm_info',
          params: [{
            asset: { currency: 'XRP' },
            asset2: { currency: CURRENCY_HEX, issuer: ISSUER }
          }]
        });
        const amm = ammWrap.result && ammWrap.result.amm;
        if (amm && xrbtcAmmEl) {
          const reserveXrp = Number(amm.amount) / XRP_TO_DROPS;
          const reserveTok = Number(amm.amount2.value);
          if (reserveXrp > 0 && reserveTok > 0) {
            const mid = reserveXrp / reserveTok;
            xrbtcAmmEl.textContent =
              'AMM: ' + mid.toFixed(6) + ' XRP/JCS';
          } else {
            xrbtcAmmEl.textContent = 'AMM: ‚Äî';
          }
        } else if (xrbtcAmmEl) {
          xrbtcAmmEl.textContent = 'AMM: ‚Äî';
        }
      } catch {
        if (xrbtcAmmEl) xrbtcAmmEl.textContent = 'AMM: ‚Äî';
      }
    } catch (e) {
      if (priceOutputEl) priceOutputEl.textContent =
        'Metrics error: ' + (e.message || e);
      if (ledgerOutputEl) ledgerOutputEl.textContent = '‚Äî';
    }
  }

  const btnHealthScan = $('btnHealthScan');
  const healthProgress = $('healthProgress');
  const healthStatus = $('healthStatus');
  const healthTable = $('healthTable');
  const healthBody = $('healthBody');
  const lastScanEl = $('lastScan');
  const riskOnlyEl = $('riskOnly');
  const watchOnlyEl = $('watchOnly');
  const autoRefreshEl = $('autoRefresh');
  const autoEveryEl = $('autoEvery');
  const btnExportJson = $('btnExportJson');
  const btnCopyJson = $('btnCopyJson');
  const btnHealthRetry = $('btnHealthRetry');

  let healthData = [];
  let healthTimer = null;
  const watchSet = new Set();

  function setHealthStatus(msg, cls) {
    setStatus(healthStatus, msg, cls);
  }

  function setHealthProgress(pct) {
    if (!healthProgress) return;
    const v = Math.max(0, Math.min(100, pct));
    healthProgress.style.width = v + '%';
  }

  function scoreFromPool(reserveXrp, reserveTok, slip10, slip100) {
    if (!isFinite(reserveXrp) || !isFinite(reserveTok)) return { score: 0, label: 'R' };
    const liq = reserveXrp;
    let score = 0;
    if (liq > 2000) score += 40;
    else if (liq > 500) score += 25;
    else if (liq > 100) score += 15;

    if (slip10 < 1) score += 25;
    else if (slip10 < 3) score += 15;
    else if (slip10 < 6) score += 8;

    if (slip100 < 3) score += 35;
    else if (slip100 < 8) score += 22;
    else if (slip100 < 15) score += 10;

    let label = 'R';
    if (score >= 70) label = 'H';
    else if (score >= 40) label = 'C';
    return { score, label };
  }

  function renderHealthTable() {
    if (!healthTable || !healthBody) return;

    const riskOnly = !!(riskOnlyEl && riskOnlyEl.checked);
    const watchOnly = !!(watchOnlyEl && watchOnlyEl.checked);

    const rows = healthData.filter(r => {
      if (watchOnly && !watchSet.has(r.key)) return false;
      if (riskOnly && r.status !== 'R') return false;
      return true;
    });

    if (!rows.length) {
      healthTable.style.display = 'none';
      return;
    }

    healthBody.innerHTML = '';
    rows.forEach(row => {
      const tr = document.createElement('tr');

      const starTd = document.createElement('td');
      const star = document.createElement('span');
      star.className = 'icon-star' + (watchSet.has(row.key) ? ' on' : '');
      star.textContent = '‚òÖ';
      star.addEventListener('click', () => {
        if (watchSet.has(row.key)) watchSet.delete(row.key);
        else watchSet.add(row.key);
        renderHealthTable();
      });
      starTd.appendChild(star);

      const tokTd = document.createElement('td');
      const tokDiv = document.createElement('div');
      const tokTop = document.createElement('div');
      const tokBot = document.createElement('div');
      tokTop.style.display = 'flex';
      tokTop.style.alignItems = 'center';
      tokTop.style.gap = '4px';

      const img = document.createElement('img');
      img.src = iconUrlForToken(row.currencyHex, row.issuer);
      img.alt = row.ticker + ' icon';

      const nameSpan = document.createElement('span');
      nameSpan.textContent = row.ticker;

      const hexSpan = document.createElement('span');
      hexSpan.className = 'mono small';
      hexSpan.textContent = row.currencyHex.slice(0, 8) + '‚Ä¶';

      tokTop.appendChild(img);
      tokTop.appendChild(nameSpan);
      tokTop.appendChild(hexSpan);

      tokBot.className = 'small mono';
      tokBot.textContent = row.issuer;

      tokDiv.appendChild(tokTop);
      tokDiv.appendChild(tokBot);
      tokTd.appendChild(tokDiv);

      const poolTd = document.createElement('td');
      poolTd.textContent = 'XRP / ' + row.ticker;

      const resTd = document.createElement('td');
      resTd.innerHTML =
        Number(row.reserveXrp).toFixed(2) + ' XRP<br>' +
        Number(row.reserveTok).toFixed(2) + ' ' + row.ticker;

      const feeTd = document.createElement('td');
      feeTd.textContent = row.feePct.toFixed(3) + '%';

      const slipTd = document.createElement('td');
      slipTd.innerHTML =
        row.slip10.toFixed(2) + '% / ' +
        row.slip100.toFixed(2) + '%';

      const scoreTd = document.createElement('td');
      scoreTd.textContent = row.score.toFixed(0) + '/100';

      const statusTd = document.createElement('td');
      const pill = document.createElement('span');
      pill.className = 'pill ' + row.status;
      pill.textContent =
        row.status === 'H' ? 'Healthy' :
        row.status === 'C' ? 'Caution' : 'Risk';
      statusTd.appendChild(pill);

      tr.appendChild(starTd);
      tr.appendChild(tokTd);
      tr.appendChild(poolTd);
      tr.appendChild(resTd);
      tr.appendChild(feeTd);
      tr.appendChild(slipTd);
      tr.appendChild(scoreTd);
      tr.appendChild(statusTd);

      healthBody.appendChild(tr);
    });

    healthTable.style.display = '';
  }

  async function scanHealth() {
    setHealthProgress(10);
    setHealthStatus('Scanning JCS AMM pool‚Ä¶');

    try {
      const ammWrap = await xrplRequest({
        method: 'amm_info',
        params: [{
          asset: { currency: 'XRP' },
          asset2: { currency: CURRENCY_HEX, issuer: ISSUER }
        }]
      });

      const amm = ammWrap.result && ammWrap.result.amm;
      const ledgerIndex = ammWrap.result && ammWrap.result.ledger_index;

      if (!amm) {
        healthData = [];
        renderHealthTable();
        setHealthProgress(0);
        setHealthStatus('No XRP/JCS AMM pool found.', 'err');
        return;
      }

      const reserveXrp = Number(amm.amount) / XRP_TO_DROPS;
      const reserveTok = Number(amm.amount2.value);
      const feePct = (amm.trading_fee || 0) / 1000;

      function slipFor(xrpIn) {
        const k = reserveXrp * reserveTok;
        const newXrp = reserveXrp + xrpIn;
        const newTok = k / newXrp;
        const outTok = reserveTok - newTok;
        if (outTok <= 0) return 100;
        const mid = reserveTok === 0 ? Infinity : reserveXrp / reserveTok;
        const effPx = xrpIn / outTok;
        return mid === 0 ? 0 : ((effPx - mid) / mid) * 100;
      }

      const slip10 = slipFor(10);
      const slip100 = slipFor(100);

      const { score, label } =
        scoreFromPool(reserveXrp, reserveTok, slip10, slip100);

      healthData = [{
        key: CURRENCY_HEX + ':' + ISSUER,
        ticker: APP_NAME,
        currencyHex: CURRENCY_HEX,
        issuer: ISSUER,
        reserveXrp,
        reserveTok,
        feePct,
        slip10: Math.max(0, slip10),
        slip100: Math.max(0, slip100),
        score,
        status: label,
        ledger_index: ledgerIndex || null,
        ts: nowIso()
      }];

      setHealthProgress(100);
      renderHealthTable();
      setTimeout(() => setHealthProgress(0), 300);

      setHealthStatus('Scan complete.', label === 'R' ? 'err' :
        label === 'C' ? '' : 'ok');

      if (lastScanEl) {
        lastScanEl.textContent =
          'Last scan: ' + nowIso().replace('T', ' ').replace('Z', ' UTC');
      }
    } catch (e) {
      healthData = [];
      renderHealthTable();
      setHealthProgress(0);
      setHealthStatus('Health scan error: ' + (e.message || e), 'err');
    }
  }

  if (btnHealthScan) {
    btnHealthScan.addEventListener('click', () => {
      if (!currentAccount) {
        setHealthStatus('Connect wallet first.', 'err');
        return;
      }
      scanHealth();
    });
  }

  if (riskOnlyEl) riskOnlyEl.addEventListener('change', renderHealthTable);
  if (watchOnlyEl) watchOnlyEl.addEventListener('change', renderHealthTable);

  function setupHealthAutoRefresh() {
    if (!autoRefreshEl || !autoEveryEl) return;
    if (healthTimer) {
      clearInterval(healthTimer);
      healthTimer = null;
    }
    if (!autoRefreshEl.checked) return;

    const secs = Number(autoEveryEl.value || '15') || 15;
    healthTimer = setInterval(() => {
      if (!currentAccount) return;
      scanHealth();
    }, secs * 1000);
  }

  if (autoRefreshEl) {
    autoRefreshEl.addEventListener('change', setupHealthAutoRefresh);
  }
  if (autoEveryEl) {
    autoEveryEl.addEventListener('change', setupHealthAutoRefresh);
  }

  if (btnExportJson) {
    btnExportJson.addEventListener('click', () => {
      try {
        const blob = new Blob(
          [JSON.stringify(healthData || [], null, 2)],
          { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'jcs-liquidity-sentinel.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        setResult('Exported Liquidity Sentinel JSON.');
      } catch (e) {
        setHealthStatus('Export error: ' + (e.message || e), 'err');
      }
    });
  }

  if (btnCopyJson) {
    btnCopyJson.addEventListener('click', async () => {
      try {
        if (!navigator.clipboard) {
          throw new Error('Clipboard API not available');
        }
        await navigator.clipboard.writeText(
          JSON.stringify(healthData || [], null, 2)
        );
        setResult('Liquidity Sentinel JSON copied to clipboard.');
      } catch (e) {
        setHealthStatus('Copy error: ' + (e.message || e), 'err');
      }
    });
  }

  if (btnHealthRetry) {
    btnHealthRetry.addEventListener('click', () => {
      if (!currentAccount) {
        setHealthStatus('Connect wallet first.', 'err');
        return;
      }
      scanHealth();
    });
  }

  const quickConfigs = [
    { btnId: 'buy1',   estId: 'est1',   amount: 1 },
    { btnId: 'buy25',  estId: 'est25',  amount: 25 },
    { btnId: 'buy50',  estId: 'est50',  amount: 50 },
    { btnId: 'buy100', estId: 'est100', amount: 100 }
  ];
  const btnRefreshEst = $('btnRefreshEst');
  const btnTrustXRBT = $('btnTrustXRBT');

  async function refreshQuickEstimates() {
    const px = await getMarketPrice('buy').catch(() => null);
    quickConfigs.forEach(cfg => {
      const estEl = $(cfg.estId);
      if (!estEl) return;
      if (!px || px <= 0) {
        estEl.textContent = '‚âà ‚Äî XRP';
      } else {
        const total = cfg.amount * px;
        estEl.textContent = '‚âà ' + total.toFixed(4) + ' XRP';
      }
    });
  }

  async function doQuickBuy(units, statusEl) {
    if (!currentAccount) {
      setStatus(statusEl, 'Connect wallet first.', 'err');
      return;
    }
    if (!HAS_TRUSTLINE) {
      setStatus(statusEl, 'Add JCS trustline first.', 'err');
      return;
    }

    try {
      setStatus(statusEl, 'Finding route for ' + units + ' JCS‚Ä¶');
      const slip = SLIPPAGE_PCT / 100;
      const TF_PARTIAL = 0x00020000;

      const destAmt = {
        currency: CURRENCY_HEX,
        issuer: ISSUER,
        value: String(units)
      };

      const r = await xrplRequest({
        method: 'ripple_path_find',
        params: [{
          source_account: currentAccount,
          destination_account: currentAccount,
          destination_amount: destAmt,
          source_currencies: [{ currency: 'XRP' }]
        }]
      });

      const alts = (r.result && r.result.alternatives) || [];
      if (!alts.length) throw new Error('No path found');

      let best = null, bestDrops = Infinity;
      for (const alt of alts) {
        const sa = alt.source_amount;
        let drops = Infinity;
        if (typeof sa === 'string') drops = Number(sa);
        else if (sa && sa.currency === 'XRP') {
          drops = Math.round(Number(sa.value) * XRP_TO_DROPS);
        }
        if (isFinite(drops) && drops < bestDrops) {
          bestDrops = drops;
          best = alt;
        }
      }
      if (!best) throw new Error('No XRP path');

      const maxDrops = Math.ceil(bestDrops * (1 + slip));

      const tx = {
        TransactionType: 'Payment',
        Destination: currentAccount,
        Amount: destAmt,
        SendMax: String(maxDrops),
        Flags: TF_PARTIAL,
        DeliverMin: {
          currency: CURRENCY_HEX,
          issuer: ISSUER,
          value: (units * (1 - slip)).toFixed(6)
        },
        Paths: best.paths_computed || best.paths_canonical || []
      };

      setStatus(statusEl, 'Open Xaman to review quick buy.');
      await signWithSentinel(tx, 'quick_buy');
      setStatus(statusEl, 'Quick buy submitted.', 'ok');
      setResult('Quick buy ' + units + ' JCS submitted.');
      await refreshAll();
    } catch (e) {
      setStatus(statusEl, 'Quick buy error: ' + (e.message || e), 'err');
    }
  }

  quickConfigs.forEach(cfg => {
    const btn = $(cfg.btnId);
    const estEl = $(cfg.estId);
    if (!btn || !estEl) return;
    btn.addEventListener('click', () => doQuickBuy(cfg.amount, estEl));
  });

  if (btnRefreshEst) {
    btnRefreshEst.addEventListener('click', () => {
      refreshQuickEstimates().catch(() => {});
    });
  }

  if (btnTrustXRBT && setTrustBtn) {
    btnTrustXRBT.addEventListener('click', () => {
      if (!setTrustBtn.disabled) {
        setTrustBtn.click();
      } else {
        setStatus($('buyStatus'), 'Trustline already present or wallet not connected.', 'ok');
      }
    });
  }

  const btnClearLog = $('btnClearLog');

  if (btnClearLog && logEl) {
    btnClearLog.addEventListener('click', () => {
      logEl.textContent = '';
      if (resultBox) resultBox.textContent = 'Receipts and messages will appear here.';
    });
  }

  async function refreshAll() {
    const tasks = [];

    tasks.push(refreshOrderBookAndLedger());

    if (currentAccount) {
      tasks.push(fetchOffers(currentAccount));
      if (autoRefreshEl && autoRefreshEl.checked) {
        tasks.push(scanHealth());
      }
    }

    tasks.push(refreshQuickEstimates());

    try {
      await Promise.allSettled(tasks);
    } catch {}
  }

  refreshOrderBookAndLedger().catch(() => {});
  refreshQuickEstimates().catch(() => {});
  setupHealthAutoRefresh();

})();
</script>

<!-- Particles background -->
<script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
<script>
  particlesJS("particles-js", {
    "particles": {
      "number": { "value": 3, "density": { "enable": false } },
      "shape": { "type": "image", "image": { "src": "cross1.png", "width": 40, "height": 40 } },
      "opacity": { "value": 0.95 },
      "size": { "value": 46, "random": true },
      "line_linked": { "enable": false },
      "move": { "enable": true, "speed": 0.45, "direction": "top", "out_mode": "out" }
    },
    "retina_detect": true
  });
</script>

<!-- Rotating Scripture of the Day -->
<script>
  const verses = [
    { ref: "John 3:16", text: "For God so loved the world that he gave his only begotten Son, that whosoever believeth in him should not perish, but have everlasting life." },
    { ref: "Psalm 23:1", text: "The LORD is my shepherd; I shall not want." },
    { ref: "Philippians 4:13", text: "I can do all things through Christ which strengtheneth me." },
    { ref: "Romans 8:28", text: "All things work together for good to them that love God, to them who are the called according to his purpose." },
    { ref: "Proverbs 3:5-6", text: "Trust in the LORD with all thine heart; and lean not unto thine own understanding." },
    { ref: "Isaiah 40:31", text: "They that wait upon the LORD shall renew their strength." },
    { ref: "Matthew 5:16", text: "Let your light so shine before men, that they may see your good works, and glorify your Father which is in heaven." },
    { ref: "Ephesians 2:8-9", text: "By grace are ye saved through faith; and that not of yourselves: it is the gift of God." },
    { ref: "Jeremiah 29:11", text: "I know the thoughts that I think toward you, saith the LORD, thoughts of peace, and not of evil." },
    { ref: "2 Corinthians 5:7", text: "For we walk by faith, not by sight." }
  ];

  function rotateVerseDaily() {
    const el = document.getElementById("dailyVerse");
    if (!el) return;
    const dayIndex = Math.floor(Date.now() / (1000 * 60 * 60 * 24)) % verses.length;
    const v = verses[dayIndex];
    el.textContent = v ? `${v.ref} ‚Äî "${v.text}"` : "";
  }

  rotateVerseDaily();
  setInterval(rotateVerseDaily, 45000);
</script>

<!-- Rotating Words of Jesus -->
<script>
  const jesusWordsList = [
    { ref: "John 14:6", text: "I am the way, the truth, and the life: no man cometh unto the Father, but by me." },
    { ref: "Matthew 11:28", text: "Come unto me, all ye that labour and are heavy laden, and I will give you rest." },
    { ref: "John 8:12", text: "I am the light of the world: he that followeth me shall not walk in darkness, but shall have the light of life." },
    { ref: "Matthew 5:9", text: "Blessed are the peacemakers: for they shall be called the children of God." },
    { ref: "Matthew 6:33", text: "Seek ye first the kingdom of God, and his righteousness; and all these things shall be added unto you." },
    { ref: "John 10:11", text: "I am the good shepherd: the good shepherd giveth his life for the sheep." },
    { ref: "John 11:25", text: "I am the resurrection, and the life: he that believeth in me, though he were dead, yet shall he live." },
    { ref: "Luke 11:9", text: "Ask, and it shall be given you; seek, and ye shall find; knock, and it shall be opened unto you." },
    { ref: "Matthew 28:20", text: "Lo, I am with you alway, even unto the end of the world." },
    { ref: "Mark 16:15", text: "Go ye into all the world, and preach the gospel to every creature." }
  ];

  function setDailyJesusWords() {
    const el = document.getElementById("jesusWords");
    if (!el) return;
    const dayIndex = Math.floor(Date.now() / (1000 * 60 * 60 * 24)) % jesusWordsList.length;
    const v = jesusWordsList[dayIndex];
    el.textContent = v ? `${v.ref} ‚Äî "${v.text}"` : "";
  }

  setDailyJesusWords();
  setInterval(setDailyJesusWords, 60000);
</script>

<!-- Cross cursor and "Amen" click -->
<script>
  document.addEventListener("mousemove", (e) => {
    let cursor = document.getElementById("cross-cursor");
    if (!cursor) {
      cursor = document.createElement("div");
      cursor.id = "cross-cursor";
      cursor.style.position = "fixed";
      cursor.style.width = "20px";
      cursor.style.height = "20px";
      cursor.style.background = "url('https://jesuschristsavestoken.com/cross1.png') center/contain no-repeat";
      cursor.style.pointerEvents = "none";
      cursor.style.zIndex = "9999";
      cursor.style.filter = "drop-shadow(0 0 8px rgba(255,215,0,0.8))";
      document.body.appendChild(cursor);
    }
    cursor.style.left = e.pageX + "px";
    cursor.style.top = e.pageY + "px";
  });

  document.addEventListener("click", (e) => {
    const amen = document.createElement("span");
    amen.innerText = "Amen ‚úùÔ∏è";
    amen.style.position = "fixed";
    amen.style.left = e.pageX + "px";
    amen.style.top = e.pageY + "px";
    amen.style.color = "#ffd700";
    amen.style.fontWeight = "800";
    amen.style.fontFamily = "Montserrat, sans-serif";
    amen.style.textShadow = "0 0 10px rgba(255,255,255,0.9)";
    amen.style.pointerEvents = "none";
    amen.style.transition = "all 1.8s ease-out";
    document.body.appendChild(amen);
    setTimeout(() => {
      amen.style.opacity = 0;
      amen.style.transform = "translateY(-60px)";
    }, 50);
    setTimeout(() => amen.remove(), 2000);
  });
</script>

<!-- XRPL metrics via xrpl.js and Coingecko -->
<script src="https://unpkg.com/xrpl@2.7.0/build/xrpl-latest-min.js"></script>
<script>
  async function fetchXRPLMetrics() {
    const issuer = "rPU6sXCNzsjcTUEmgJQ5SxDUzY2y1RyYKd";
    const currency = "JCS";
    let client;
    try {
      client = new xrpl.Client("wss://xrplcluster.com");
      await client.connect();

      const bookOffers = await client.request({
        command: "book_offers",
        taker_gets: { currency, issuer },
        taker_pays: { currency: "XRP" },
        limit: 1
      });

      let priceXRP = 0;
      if (bookOffers.result.offers && bookOffers.result.offers.length > 0) {
        const offer = bookOffers.result.offers[0];
        const takerPaysXRP = Number(offer.TakerPays) / 1_000_000;
        const takerGetsJCS = Number(offer.TakerGets.value);
        if (takerGetsJCS > 0) {
          priceXRP = takerPaysXRP / takerGetsJCS;
        }
      }

      const xrpPriceRes = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd");
      const xrpData = await xrpPriceRes.json();
      const xrpUSD = xrpData?.ripple?.usd ?? 0;
      const priceUSD = priceXRP * xrpUSD;

      const accountLines = await client.request({ command: "account_lines", account: issuer });
      let totalSupply = 0;
      for (const line of (accountLines.result.lines || [])) {
        if (line.currency === currency) {
          totalSupply += parseFloat(line.balance);
        }
      }

      const marketCap = totalSupply * (priceUSD || 0);

      const priceEl = document.getElementById('price');
      const mcEl = document.getElementById('marketcap');
      const supplyEl = document.getElementById('supply');

      if (priceEl) priceEl.innerText = priceUSD ? `$${priceUSD.toFixed(6)}` : "‚Äî";
      if (mcEl) mcEl.innerText = Number.isFinite(marketCap) ? `$${marketCap.toLocaleString()}` : "‚Äî";
      if (supplyEl) supplyEl.innerText = Number.isFinite(totalSupply) ? `${totalSupply.toLocaleString()} JCS` : "‚Äî";
      const changeEl = document.getElementById('change');
      if (changeEl) changeEl.innerText = "N/A";
    } catch (e) {
      console.error("Metrics error:", e);
    } finally {
      try { if (client) await client.disconnect(); } catch {}
    }
  }

  fetchXRPLMetrics();
  setInterval(fetchXRPLMetrics, 60000);

  // Daily blessing footer rotator
  (function() {
    const blessings = [
      "May every ledger entry remind you that Jesus Christ never changes.",
      "Walk in faith; let your stewardship be as transparent as this ledger.",
      "Jesus Christ Saves ‚Äî let your digital steps confess His name.",
      "Let your giving be in the light, your hope in the Lord.",
      "Grace and truth remain greater than any market chart."
    ];
    const footer = document.querySelector("footer");
    if (footer) {
      const bless = document.createElement("p");
      bless.id = "dailyBlessing";
      bless.style.marginTop = "12px";
      bless.style.color = "#fff8dc";
      bless.style.fontWeight = "600";
      bless.style.textShadow = "0 0 8px rgba(255,255,255,0.6)";
      bless.innerText = blessings[Math.floor(Math.random() * blessings.length)];
      footer.appendChild(bless);
      setInterval(() => {
        bless.innerText = blessings[Math.floor(Math.random() * blessings.length)];
      }, 60000);
    }
  })();
</script>
</body>
</html>
